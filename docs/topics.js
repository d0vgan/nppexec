var NPPEXEC_HELP_TOPICS = {
  "1. What is NppExec": {
    "content": "1. NppExec",
    "path": "./1.html"
  },
  "1.1. Introduction": {
    "content": "1.1. Introduction NppExec plugin Notepad++ which allows run commands/programs directly Notepad++ provides output window (NppExec's Console). NppExec used running other programs Notepad++, passing text Notepad++ external tool, compiling source files (using external compiler) . When NppExec plugin installed, icon \"Show NppExec Console\" Notepad++'es toolbar, find NppExec's submenu under Plugins menu Notepad++. always find latest version NppExec https://sourceforge.net/projects/npp-plugins/ - there among other Notepad++'es plugins. latest sources NppExec found https://github.com/d0vgan/nppexec/ .",
    "path": "./1.1.html"
  },
  "1.2. NppExec is...": {
    "content": "1.2. NppExec ... + NppExec intermediary between Notepad++ external tool/compiler. allows run external tool/compiler directly Notepad++. + NppExec Console window which show running process'es output, redirect Console window's input running process (with limitations). + NppExec interpreter own internal commands. NppExec execute several commands one after another (-called NppExec's script) \"Execute NppExec Script...\" dialog execute single command multiple commands directly Console window.",
    "path": "./1.2.html"
  },
  "1.3. NppExec is not...": {
    "content": "1.3. NppExec ... - NppExec console emulator. NppExec redirects running process'es output Console window, redirect Console window's input running process (with limitations). NppExec's Console \"real\" console window (actually, uses RichEdit control text input/output), provide console screen buffer. Thus, console application which requires \"real\" console screen buffer must run own console window (using NPP_RUN command). - NppExec command interpreter. NppExec understand such commands 'copy', 'call', '' because neither \"real\" console console emulator. However, NppExec own internal implementation such commands 'cls', 'cd', 'dir', 'echo', 'set' ('env_set') introduces other, specific, commands. Also use \"cmd /c <command>\" execute cmd's command inside NppExec. - NppExec compiler. NppExec allows use external tools compilers process/compile current file, ability by itself. magic here :)",
    "path": "./1.3.html"
  },
  "2. Installation": {
    "content": "2. Installation",
    "path": "./2.html"
  },
  "2.1. What? Installation?": {
    "content": "2.1. ? Installation? Usually latest stable version NppExec installed via Notepad++'es Plugin Manager, have anything complicated. However, may know: actually NppExec plugin how installed removed; how install latest version NppExec; how use several copies NppExec.",
    "path": "./2.1.html"
  },
  "2.2. The NppExec plugin (NppExec.dll)": {
    "content": "2.2. NppExec plugin (NppExec.dll) NppExec dynamic-link library (DLL) implemented plugin Notepad++. Actually (physically) NppExec plugin one file named \"NppExec.dll\". This file (\"NppExec.dll\") must placed (copied) Notepad++'es Plugins subfolder order work with Notepad++.",
    "path": "./2.2.html"
  },
  "2.3. Installing the latest version": {
    "content": "2.3. Installing latest version always find latest version NppExec https://sourceforge.net/projects/npp-plugins/ - there among other Notepad++'es plugins. latest sources NppExec found https://github.com/d0vgan/nppexec/ . Once download archive containing latest \"NppExec.dll\" file, extract content this archive Notepad++'es Plugins subfolder ( may need overwrite existing NppExec's files with latest ones). Also may interested documentation inside archive always contains latest information NppExec's commands variables, advanced options changes. If sure \"Notepad++'es Plugins subfolder\", following: locate file \"notepad++.exe\" computer (usually located somewhere here: C:\\Program Files\\Notepad++\\notepad++.exe); go folder which contains file \"notepad++.exe\" (e.g. C:\\Program Files\\Notepad++); go subfolder \"plugins\" (e.g. C:\\Program Files\\Notepad++\\plugins); there! :)",
    "path": "./2.3.html"
  },
  "2.4. Using several copies of NppExec": {
    "content": "2.4. Using several copies NppExec have several copies \"NppExec.dll\" Notepad++'es Plugins subfolder order have several NppExec's Console windows. Each copy NppExec saves own options own console commands history (if enabled NppExec's options). same time, saved NppExec's scripts shared between several copies NppExec. have several copies \"NppExec.dll\", just copy with different name(s), example, \"NppExec2.dll\", \"NppExecCpp.dll\", \"NppExecWeb.dll\" . This will give additional NppExec's Console windows with corresponding titles: \"Console2\", \"ConsoleCpp\", \"ConsoleWeb\" . Note: modern versions Notepad++, each instance NppExec.dll should located own folder. Thus, have e.g. \"NppExecCpp.dll\", make copy entire folder \"plugins\\NppExec\" \"plugins\\NppExecCpp\" then rename \"plugins\\NppExecCpp\\NppExec.dll\" \"plugins\\NppExecCpp\\NppExecCpp.dll\". ( sure that .dll name matches folder name!) Also, sure have inner subfolder \"NppExecCpp\\NppExec\" (that contains \"BaseDef.h\", \"menuCmdID.h\" ) because each instance NppExec.dll needs near itself. (This inner \"NppExec\" subfolder should preserve initial name). sum up, following files/folders tree expected case \"NppExec.dll\" \"NppExecCpp.dll\": plugins\\ NppExec\\ NppExec\\ BaseDef.h menuCmdID.h Notepad_plus_msgs.h Scintilla.h NppExec.dll NppExecCpp\\ NppExec\\ BaseDef.h menuCmdID.h Notepad_plus_msgs.h Scintilla.h NppExecCpp.dll",
    "path": "./2.4.html"
  },
  "2.5. Unicode and ANSI, 32-bit and 64-bit version": {
    "content": "2.5. Unicode ANSI, 32-bit 64-bit version Originally there were two builds NppExec: Unicode build ANSI build. Unicode build compatible with Unicode Notepad++ ANSI build compatible with ANSI Notepad++. could check version Notepad++ by pressing F1 main menu (? -> Notepad++). would something similar \"Notepad++ v5.1.3 (UNICODE)\" \"Notepad++ v5.1.3 (ANSI)\". corresponding version NppExec (Unicode ANSI) required. Unicode version Notepad++ recommended. ANSI version Notepad++ existed just compatibility with old non-Unicode systems (such Windows 98 Millenium) with old non-Unicode plugins. Talking NppExec, Unicode build more powerful because fully Unicode interface supports input files ANSI, UTF-8, UCS-2 LE (Unicode wide characters Windows) UCS-2 encodings. ANSI version NppExec supported just ANSI input files. caused by following reason: conversion UTF-8 UCS-2 ANSI might lead loss Unicode characters which have ANSI analogue. Starting Windows 2000, operational system (.e. Windows) itself Unicode, which means internally operates with Unicode characters. next versions Windows, such Windows XP, Windows Vista Windows 7, also have Unicode core. now, when most people have least Windows 7 ( even Windows 10), there much sense having non-Unicode text editor while Windows itself Unicode natively. today's Notepad++ Unicode program, well NppExec, Notepad++'s plugin, also Unicode. With today's 64-bit (also known \"x64\") CPUs operational systems, more more software become 64-bit. Notepad++ also available 64-bit (x64) 32-bit (x86) application. 64-bit Notepad++ runs under 64-bit Windows allows use more RAM - practice means open larger files (with size 1 GB more) with . 32-bit Notepad++ runs under both 64-bit 32-bit Windows additionally supports old 32-bit plugins that have been ported 64-bit yet. Luckily, NppExec available both 64-bit 32-bit versions, up which version Notepad++ choose :)",
    "path": "./2.5.html"
  },
  "3. Basic usage": {
    "content": "3. Basic usage",
    "path": "./3.html"
  },
  "3.1. Getting help": {
    "content": "3.1. Getting help description all commands environment variables supported by current version NppExec found file \"NppExec.txt\". Usually find this file downloaded NppExec's archive Notepad++'es Plugins subfolder ( \"doc\" subfolder). Also open \"NppExec.txt\" Notepad++ via Plugins -> NppExec -> Help/Docs... All advanced \"hidden\" settings current version NppExec described file \"NppExec_TechInfo.txt\". Usually find this file same place where file \"NppExec.txt\" located. Also open \"NppExec_TechInfo.txt\" Notepad++ via Plugins -> NppExec -> Help/Docs... Remark: change advanced settings using NppExec's Advanced Options dialog. most recent detailed information all NppExec's commands environment variables found NppExec's built- help. use built- help, open NppExec's Console , type \"help\" press Enter. ll long list which contains: - NppExec's Console hotkeys; - NppExec's Console commands (which work Console only); - NppExec's general commands (which work everywhere NppExec); - NppExec's predefined environment variables. get detailed help NppExec's command, type \"help <command>\" press Enter. example, \"help set\", \"help inputbox\", \"help npp_exec\" . detailed help usually contains command description, examples remarks. This most essential information. get all available NppExec's help once, type \"help all\" press Enter. save all help into text file, type \"help all\" first then type following: con_saveto $(NPP_DIRECTORY)\\plugins\\doc\\NppExec\\NppExec_HelpAll.txt additional information found NppExec's Help/ window. example: - execute NppExec's commands scripts directly Console window; - Commands case-insensitive (.e. NPP_OPEN same Npp_Open); - . , course, we should forget this manual itself. intention lead through NppExec usage simple advanced features. , if understand something section, most likely been described previous sections. example, let's remind section : says \"NppExec console emulator\". mean us? Let's analyse. NppExec provides graphical \"Console\" window, regular text-mode console. \"Console\" window only looks similar regular text-mode console, provide all features . NppExec's Console window show output even allows input - this may possible applications which require native features regular text-mode console. By same reason, may encounter different behaviour applications under NppExec's Console regular console. (Such limitations intentional - they caused by implementation-specific things which seem application-related system-related thus NppExec's control.) Also says \"NppExec command interpreter\". We already have discussed that NppExec console emulator, here another thing remember: NppExec cmd.exe! means NppExec nothing with native cmd's commands even invoke cmd.exe until specify explicitly. NppExec only execute own commands run external executables specify. Thus, generally speaking, NppExec cmd.exe completely different things may expect same behaviour NppExec cmd.exe. Though always invoke cmd.exe explicitly. We will return this , , ,  . , finally, says \"NppExec compiler\". have suggestions this statement already? guess :) Yes, NppExec itself compile file. NppExec simply know with that file. completely up specify correct compiler certain file - NppExec will run that compiler . before specify explicitly. We will return this  . , generally speaking, NppExec tool. This tool exactly tell - with assumptions, implicit invoking something . magic here . goal this manual teach use NppExec. Sometimes will find direct examples which match needs exactly - there will general approach which should used cope with task. Applying this general approach specific needs, will adapting these needs anyway - effort will required case. this manual - - cover everything. Instead, demonstrates achieve with NppExec HOW achieve that. Once understand principles, use NppExec purpose. Good luck!",
    "path": "./3.1.html"
  },
  "3.2. Do something (intro)": {
    "content": "3.2. something (intro) main principle NppExec same Notepad++'es \"Run...\" command (F5): execute command given. Usually means run program/tool with specified parameters which passed form Notepad++'es environment variables. example, allows launch current file Internet Explorer compile current file using certain compiler. NppExec provides additional abilities this: - Console window show console program's output - allows execute several commands one after another - supports all Notepad++'es environment variables plus several own variables - additional commands which allow more than expect :) - cool :) NppExec actually provides four different execute command(s): using NppExec's Console - allows enter command execute by pressing Enter; using dialog \"Execute NppExec Script...\" - allows enter several commands (which will executed one after another) save these commands NppExec's script; using NppExec's command \"npp_exec <script>\" - allows execute commands existing NppExec's script ; using NppExec's command \"npp_exec <file>\" - allows execute commands existing text file . By , NppExec uses 3rd (described above) menu items which allow execute NppExec's script. Remarks: NppExec by itself understands only own internal commands environment variables. When type another command, such \"copy\", \"cmd\" \"calc\", NppExec tries run child process - .e. performs CreateProcess(...) waits until this process ends. (Note: NppExec ver. 0.6 RC3 introduces new advanced option \"ChildProcess_RunPolicy\" that allows modify this behavior. Refer more details.) When type something like \"npp_run cmd\" \"npp_run calc\", NppExec tries run specified command ( argument npp_run) external process - .e. performs ShellExecute(...) this process.",
    "path": "./3.2.html"
  },
  "3.3. Do something (how-to)": {
    "content": "3.3. something (how-) run program (optionally, with parameters) child process NppExec, just type (path)name this program (optionally, with parameters) NppExec's Console \"Execute NppExec Script...\" dialog . This makes NppExec : run program (optionally, with parameters) show output NppExec's Console (if console program) wait until program exits example, type cmd start \"cmd.exe\". will cmd's output NppExec's Console. type cmd's commands order cmd execute them , finally, type \"exit\" order exit cmd. Also type calc order start \"calc.exe\". NppExec will wait until close calc's window. Finally, here example with parameters: cmd /c time /t last example shows output cmd's command \"time /t\" NppExec's Console - .e. shows current time. same approach used execute .bat .cmd files - file extension (.bat .cmd) omitted this case. (Note: NppExec ver. 0.6 RC3 introduces new advanced option \"ChildProcess_RunPolicy\" that allows modify this behavior. Refer more details.) run program (optionally, with parameters) external process (with respect NppExec), type \"npp_run \" (path)name this program (optionally, with parameters) NppExec's Console \"Execute NppExec Script...\" dialog . This makes NppExec : run program (optionally, with parameters) console program shown own console window NppExec wait until program exits example, type npp_run cmd start \"cmd.exe\" own window. (Note: possible start application own window make NppExec wait until application been executed. that, type: cmd /c start /wait application.exe this case, NppExec waits 'cmd' executed, while 'cmd' itself starts 'application.exe' own separate window waits until been executed. \"npp_run \" needed here.) Also use \"npp_run \" open specified file associated program. example, \"npp_run index.htm\" opens .htm file default internet browser. also: Using cmd.exe .",
    "path": "./3.3.html"
  },
  "3.4. NppExec's submenu": {
    "content": "3.4. NppExec's submenu access NppExec's submenu Notepad++'es main menu: Plugins -> NppExec. This submenu contains following items: Execute NppExec Script... - shows \"Execute NppExec Script...\" dialog ; Execute Previous NppExec Script - executes previous NppExec's script immediately; Execute Selected Text - executes text selected Notepad++ NppExec's script sends running child process input; Execute Clipboard Text - executes text clipboard NppExec's script sends running child process input; Show NppExec Console - shows/hides NppExec's Console ; Toggle NppExec Console - activates/deactivates NppExec's Console (depends Console's option \"Hide toggled Console\" ); Go next error - goes next error/warning Console, basing HighLight masks (NppExec Console Filters); Go previous error - goes previous error/warning Console, basing HighLight masks (NppExec Console Filters); Console Commands History - enables/disables NppExec's Console's commands history; Console Output... {OEM/OEM} - shows \"Console Output/Input encoding\" dialog; internal messages - disables command confirmations NppExec's Console; Save all files execute - (always) save all modified files before executing NppExec's script; Follow $(CURRENT_DIRECTORY) - (always) set current directory active file's path; Console Output Filters... - shows \"NppExec Console Filters\" dialog; Advanced Options... - shows \"NppExec Advanced Options\" dialog; Change Console Font... - allows change NppExec Console's font ; Change Execute Script Font... - allows change Execute NppExec Script's font ; Help/Manual - shows this manual; Help/Docs... - opens \"NppExec.txt\" \"NppExec_TechInfo.txt\" Notepad++; Help/... - shows information plugin. Note: create additional menu items NppExec's scripts. more details.",
    "path": "./3.4.html"
  },
  "3.5. NppExec's Console": {
    "content": "3.5. NppExec's Console NppExec's Console shown using toolbar button \"Show NppExec Console\" menu item \"Show NppExec Console\" NppExec's submenu (Plugins -> NppExec -> Show Console). * By , reassign toolbar button even disable via NppExec's \"Advanced options...\" dialog. NppExec's Console used : show running console process'es output; optionally, Console Output Filters used. This happens when child console process being executed; show NppExec's internal messages (command confirmations - disabled with \" internal messages\" option). This happens when (also may before after) command executed; show NppExec's built- help. This happens when type \"help\" \"help <command>\" (e.g. \"help npp_run\", \"help set\" .) Console; go specified line specified file by double-clicking Console's line which contains file (path)name line - using Console Output Filters -> HighLight; execute single command multiple commands by typing them Console pressing Enter; copy (Ctrl+C) text paste (Ctrl+V) Console; more; type \"help\" Console details. also: NppExec's Console behaviour ; Console output redirection .",
    "path": "./3.5.html"
  },
  "3.6. Execute NppExec Script...": {
    "content": "3.6. Execute NppExec Script... \"Execute NppExec Script...\" dialog shown using hotkey (F6 by default) menu item \"Execute NppExec Script...\" NppExec's submenu (Plugins -> NppExec -> Execute NppExec Script...). \"Execute NppExec Script...\" dialog allows specify several NppExec's commands (one command per one line) which will executed one after another. Such set commands forms -called NppExec's script. script saved using \"Save...\" button \"Execute NppExec Script...\" dialog. example, create NppExec's script which makes reserve copy current file: 1) open \"Execute NppExec Script...\" dialog type following // save current file NPP_SAVE // copy current file C:\\Backup cmd /c copy \"$(FULL_CURRENT_PATH)\" \"C:\\Backup\\$(FILE_NAME)\" /Y 2) press \"Save...\" button, type \"Reserve Copy\" press \"Save\" button. This example allows create save NppExec's script named \"Reserve Copy\". call this script later \"Execute NppExec Script...\" dialog. Also create menu item this script using NppExec's Advanced Options (Plugins -> NppExec -> Advanced Options...). necessary save new script each time execute several commands. use \"<temporary script>\" commands need save. temporary script saved automatically when close Notepad++. Also, if modify commands saved script (e.g. if modify \"Reserve Copy\" script), will saved automatically when close Notepad++. press \"Save\" button save immediately. delete previously saved scripts using \"Execute NppExec Script...\" dialog. Press \"Save...\" button (yes, irony :)), select script name press \"Delete\" button. also: NppExec's script .",
    "path": "./3.6.html"
  },
  "3.7. NppExec's script": {
    "content": "3.7. NppExec's script NppExec's script set NppExec's commands. NppExec's command internal command such \"cls\", \"npp_save\", \"npe_debuglog\" . (path)name executable such \"cmd\", \"calc\", \"C:\\tools\\tcc\\tcc.exe\" . Each command, depending meaning, have one more parameters. example: INPUTBOX \"Input something:\" : something NPP_EXEC \"script name\" \"param 1\" \"param 2\" cmd /c copy /? \"C:\\tools\\tcc\\tcc.exe\" -run \"$(FULL_CURRENT_PATH)\" . use \"//\" comment entire line right part line (after \"//\"): // this comment ECHO ll this // this (comment) create save NppExec's scripts using \"Execute NppExec Script...\" dialog . However, NppExec's script also located text file. .e. create text file which contains NppExec's commands (one command per one line) then execute this file (commands this file) NppExec. Such text file ANSI file ANSI version NppExec ANSI Unicode (UCS-2 LE/UCS-2 /UTF-8) file Unicode version NppExec. Note that Unicode text file must contain leading \"BOM\" bytes recognized by Unicode version NppExec (by default, these bytes present - until force saving without \"BOM\"). execute NppExec's script text file, use \"npp_exec\" command. This command allows execute commands previously saved (internal) script (external) text file. store NppExec's script text file, edit such file directly Notepad++ execute with following command(s): NPP_SAVE // save current file (NppExec's script)... NPP_EXEC \"$(FULL_CURRENT_PATH)\" // ... execute With Console Commands History enabled, type this command: NPP_EXEC \"$(FULL_CURRENT_PATH)\" NppExec's Console once, then use Arrow Up key repeat this command. However, sure save current file (with Ctrl+S) before executing . create menu item NppExec's script, use NppExec's Advanced Options dialog. Then shortcut key assigned : Create menu item script using Plugins -> NppExec -> Advanced options (select script \"Associated script\" drop-down list, specify menu item name - by default same script name - press \"/Modify\" button). Restart Notepad++ get this new menu item. Assign shortcut key this new menu item using Notepad++'es Settings -> Shortcut Mapper -> Plugin commands (ll find menu item there). NppExec stores scripts Notepad++'es \"$(PLUGINS_CONFIG_DIR)\" folder. \"npes_saved.txt\" file stores all scripts except temporary one which stored inside \"npes_temp.txt\". NppExec's script syntax. General notes: Commands case-insensitive. Thus, npp_open same NPP_OPEN , Npp_Open . Use help <command> get detailed help NppExec's <command>. example: help npp_open , help set , help sci_sendmsg . Use spaces separate parameters NppExec's command. use neither brackets commas: sci_sendmsg SCI_SETTEXT 0 \" text\" set local pos ~ strfind \"Hello world\" Hello Use \" \", ` ` ' ' around parameters that contain spaces other quote characters : sci_sendmsg SCI_SETTEXT 0 `\" text quotes\"` inputbox 'Hello World!' set local pos ~ strfind \"Hello's world\" `Hello's` set local len ~ strlen \" 34' 78 \" // returns 12, including \"\" set local len ~ $(len) - 2 // 10, without \"\" cd C:\\Program Files (x86) // cd accepts parameter without quotes Note: when command expects several parameters, extracts parameters' values by removing surrounding quotes (there rare exceptions, though, such substr that preserves surrounding quotes). If command expects just one parameter, surrounding quotes may may removed, depending command. Refer built- help by typing e.g. \"help sci_sendmsg\", \"help inputbox\", \"help set\", \"help cd\" . actual examples. Use $(var) get value internal variable named \"var\" . forget use form $(var) mathematical expressions well: set local x = 10 // assigns 10 variable 'x' set local x ~ $(x) + 1 // accesses previous value 'x' 1 Use $(sys.var) get value environment variable \"var\" . NppExec understand such form %var%: echo $(SYS.PATH) // prints value %PATH% env_set PATH = $(SYS.PATH);C:\\tools // updates value %PATH% Use cmd /C explicitly invoke system's command interpreter (cmd.exe) when needed . example: cmd /C echo %PATH% cmd /C time /t >time.txt && type time.txt cmd /C taskkill /? | findstr /ic:pid Use different forms IF-GOTO when needed: // Simple IF-GOTO if $(x) == 1 goto 1 if $(x) == 2 goto 2 echo x neither 1 2 goto end :1 echo x 1 goto end :2 echo x 2 goto end :end // IF-GOTO-ELSE if $(x) == 1 goto 1 else if $(x) == 2 goto 2 else echo x neither 1 2 goto end endif :1 echo x 1 goto end :2 echo x 2 goto end :end // IF-GOTO Loop set local N = 10 set local x = 1 :1 echo $(x) set local x ~ $(x) + 1 if $(x) <= $(N) goto 1 Use different forms IF-THEN when needed: // Simple IF-THEN if $(x) == 1 then echo x 1 endif if $(x) == 2 then echo x 2 endif echo x neither 1 2 // IF-THEN-ELSE if $(x) == 1 then echo x 1 else if $(x) == 2 then echo x 2 else echo x neither 1 2 endif // Nested IF-THEN-ELSE if $(x) == 1 then echo x 1 else if $(x) == 2 then echo x 2 else echo x neither 1 2 endif endif // IF-THEN-GOTO Loop set local N = 10 set local x = 1 :1 if $(x) <= $(N) then echo $(x) set local x ~ $(x) + 1 goto 1 endif Use IF~ calculate mathematical expressions during comparison: set local x = 8 set local y = 14 if~ $(x) + 2 == $(y) - 4 then echo left == right else echo left != right endif also: \"Execute NppExec Script...\" ; Run-time parameters .",
    "path": "./3.7.html"
  },
  "3.8. Environment variables": {
    "content": "3.8. Environment variables",
    "path": "./3.8.html"
  },
  "3.8.1. Predefined (read-only) variables": {
    "content": "3.8.1. Predefined (read-only) variables NppExec supports all basic (predefined) environment variables Notepad++ plus several own (predefined) environment variables. NppExec's help more details supported predefined variables. Consider such predefined environment variables \"read-only\": use these variables NppExec's commands scripts, modify their values. These variables exist NppExec's commands scripts - actually, these variables replaced with their current values by NppExec when use them. These variables exist outside NppExec ( exist child processes ). means 't use such variables $(FULL_CURRENT_PATH), $(NPP_DIRECTORY), $(#1) inside external programs tools. However, : 1) pass values these variables input parameters external programs/tools, e.g. // pass \"$(FULL_CURRENT_PATH)\" parameter tcc tcc -run \"$(FULL_CURRENT_PATH)\" 2) use command \"env_set\" create heritable environment variable which will accessed inside external programs/tools, e.g. // create new environment variable NPPHOME ENV_SET NPPHOME = $(NPP_DIRECTORY) // start cmd.exe cmd Now type something similar \"echo %NPPHOME%\" inside cmd order use value this environment variable.",
    "path": "./3.8.1.html"
  },
  "3.8.2. User (internal) variables": {
    "content": "3.8.2. User (internal) variables NppExec allows create, modify remove own (user) variables using NppExec's commands \"set\" \"unset\". NppExec's help more details commands \"set\" \"unset\". Consider such user variables \"internal\": these variables exist only NppExec. create, modify remove such variables NppExec's commands scripts time need: store value, set value one script order use another script . These variables exist outside NppExec ( exist child processes ). means 't use these variables inside external programs tools. However, : pass values these variables input parameters external programs/tools ( ); use command \"env_set\" create heritable environment variable which will accessed inside external programs/tools ( ). NppExec 0.5.1 introduces -called \"local variables\". They created, modified removed using NppExec's commands \"set local\" \"unset local\". local variable lives inside NppExec's script that being executed, automatically deleted when script ends. NppExec 0.6, when something similar \"set local x = 10\" executed directly NppExec's Console, this variable will live only NppExec's Console will visible NppExec's scripts. Type \"help set\" NppExec's Console more details. also: Run-time parameters .",
    "path": "./3.8.2.html"
  },
  "3.8.3. Environment (heritable) variables": {
    "content": "3.8.3. Environment (heritable) variables NppExec (ver. 0.3 RC1 higher) allows create modify (heritable) environment variables using NppExec's commands \"env_set\" \"env_unset\". NppExec's help more details commands \"env_set\" \"env_unset\". Consider such heritable environment variables \"real\" environment variables: these variables exist both inside NppExec ( form $(SYS.<var>) which allows use var's value inside NppExec) outside NppExec (usually form %<var>% which allows use modify var's value inside external tool). NppExec allows modify restore value such existing environment variable, create, modify remove such new environment variable (which did exist before create NppExec). also: Environment .",
    "path": "./3.8.3.html"
  },
  "3.8.4. Calculations, strlen and so on": {
    "content": "3.8.4. Calculations, strlen NppExec ver. 0.4 introduces built- calculator abilities provided by Function Parser (fparser). calculate math expression, use special form SET command: set result ~ <math expression> example: set result ~ sin(pi/4) + cos(pi/4) If this example gives error \"- fparser calc error: Syntax error: Unknown identifier pos 4\", means have necessary NppExec files \"Notepad++\\plugins\\NppExec\" folder. such case, need download latest NppExec package manually unpack \"Notepad++\\plugins\" folder . find more details regarding fparser's syntax abilities inside file \"Notepad++\\plugins\\doc\\NppExec\\fparser.html\". By , NppExec also uses fparser own purposes such internal implementation NPP_SENDMSG SCI_SENDMSG. particular, fparser used calculate store values constants defined inside \"Notepad_plus_msgs.h\", \"Scintilla.h\" other files \"Notepad++\\plugins\\NppExec\" folder. this just information; never mind :) There two special cases this form SET command which processed by NppExec itself. am talking set n ~ strlen <string>  set n ~ strlenutf8 <string> These two functions calculate ANSI UTF-8 string length. Latin characters, both 'strlen' 'strlenutf8' will return same value. non-Latin characters (such Cyrillic), 'strlenutf8' will return greater value than 'strlen' because each non-Latin character UTF-8 may represented by 2 3 bytes (unlike Latin characters which always represented by 1 byte UTF-8). Actually, 'strlenutf8' returns number bytes UTF-8 string. This number specified Scintilla's messages invoked via SCI_SENDMSG. Type \"help sci_sendmsg\" NppExec's Console more details regarding SCI_SENDMSG. Here example which uses 'strlen' SCI_SENDMSG: set s = My string set n ~ strlen $(s) SCI_SENDMSG SCI_APPENDTEXT $(n) \"$(s)\" If spaces before after \"My string\" (e.g. have \" My string \"), should modify script since NppExec removes leading trailing spaces around value: set s = My string // leading/trailing spaces will removed set n ~ strlen $(s) // length without leading/trailing spaces set n ~ $(n) + 2 // length with additional two spaces SCI_SENDMSG SCI_APPENDTEXT $(n) \" $(s) \" // adding spaces will encounter similar problem when calculating 'strlen' string which starts ends with spaces. These spaces will removed before calculating string length. avoid this, should enclose such string double quotes: set n ~ strlen \" ABC \" // n=8: string length with two \" symbols set n ~ $(n) - 2 // n=6: length without \" symbols NppExec ver. 0.5 introduced several additional functions: strupper, strlower substr. Even more functions have been added later. Type \"help set\" more details. Here example that uses substr extract directory name $(CURRENT_DIRECTORY) : npp_console local - set local dirname = $(CURRENT_DIRECTORY) set local c ~ substr -1 1 $(dirname) // trailing character if \"$(c)\" == \"\\\" then set local dirname ~ substr 0 -1 $(dirname) // removing trailing \\ else if \"$(c)\" == \"/\" then set local dirname ~ substr 0 -1 $(dirname) // removing trailing / endif set local n1 ~ strrfind \"$(dirname)\" \\ // position last \\ set local n2 ~ strrfind \"$(dirname)\" / // position last / if $(n1) > $(n2) then set local n1 ~ $(n1) + 1 set local dirname ~ substr $(n1) - $(dirname) else set local n2 ~ $(n2) + 1 set local dirname ~ substr $(n2) - $(dirname) endif npp_console local + echo $(dirname) Now let's discuss something different: pseudo-conditions NppExec. Pseudo-conditions available via NPP_EXEC command plus variable. next idea lies behind this: form script name dynamically order execute different script basing variable's value. Let me explain: command \"NPP_EXEC script$(var)\" will execute different script according value $(var). example, let's assume execute program then have different behaviour depending successful unsuccessful execution that program. course, use \"cmd /c program && do_something_different\" achieve this, such approach allow use NppExec-specific functions (since everything executing under cmd.exe). , let's assume we have following script: program.exe // execute program NPP_EXEC OnProgramEnd_$(EXITCODE) // pseudo-condition program \"program.exe\" expected return 0 case successful execution. Otherwise returns non-zero value. (This common behaviour executables.) Thus we create NppExec's script named \"OnProgramEnd_0\" which will called only case successful execution \"program.exe\" -- .e. when $(EXITCODE) will 0. Otherwise, case -1 1 ( ) we will try execute non-existing script \"OnProgramEnd_-1\" \"OnProgramEnd_1\" ( ). example, create following script name \"OnProgramEnd_0\" test previous statements ( pseudo-conditions, actually): // OnProgramEnd_0 echo program returned 0: executed successfully! , we say that two above scripts allow us emulate IF condition. Here meaning: IF (program.exe returns 0) THEN execute \"OnProgramEnd_0\". Otherwise we try execute non-existing script that treated \" nothing\". Going further, we implement IF-THEN-ELSE statement similar . Our script will changed little: program.exe // execute program set N ~ $(EXITCODE) != 0 NPP_EXEC OnProgramEnd_$(N) // pseudo-condition value $(N) will either 1 (true) when $(EXITCODE) 0, 0 (false) when $(EXITCODE) 0. we will execute either \"OnProgramEnd_0\" \"OnProgramEnd_1\". Now only remaining thing create script named \"OnProgramEnd_1\": // OnProgramEnd_1 echo program returned non-zero: execution failed. NppExec ver. 0.5 introduced native support IF-GOTO commands. Type \"help if\" more details. Finally, let's talk \"special\" characters NppExec. mean \"//\" ( comment) double quote symbol. While using command with comment, all text after \"//\" being cut that command. if use \"//\" part text? possible ? Yes, possible. use environment variables that: set = / // now $() \"/\" echo $()$() // prints \"//\" set s = $()$() // now $(s) \"//\" same technique used pass double quote symbol: NPP_SENDMSG WM_COMMAND IDM_FILE_NEW set q = \" sci_sendmsg SCI_SETTEXT 0 \"$(q) text double quotes$(q)\" big trick, actually, may useful :) also: Calculating ; Passing enquoted strings special characters .",
    "path": "./3.8.4.html"
  },
  "3.8.5. Passing enquoted strings and special characters": {
    "content": "3.8.5. Passing enquoted strings special characters NppExec, starting version 0.7, allows use three different quote characters enquote string: \"abc\" 'abc' `abc` This allows pass quote characters within string enquoted other quote characters. example: messagebox `\" message quotes\"` // preserves \"\" quotes messagebox \"'t stop\" // preserves single ' quote Here advanced example, now using Scintilla well: set local newline ~ strfromhex 0A 00 // '\\n' character set local s = \" string double-quotes\" set local len ~ strlensci $(newline)$(s) sci_sendmsg SCI_APPENDTEXT $(len) `$(newline)$(s)` set local t ~ strreplace '$(s)' '\"' `'` set local t ~ strreplace `$(t)` \"double\" \"single\" set local len ~ strlensci $(newline)$(t) sci_sendmsg SCI_APPENDTEXT $(len) `$(newline)$(t)` set local r ~ strreplace `$(t)` `'` \"`\" set local len ~ strlensci $(newline)$(r) sci_sendmsg SCI_APPENDTEXT $(len) \"$(newline)$(r)\" set local findflags ~ NPE_SF_INWHOLETEXT | NPE_SF_SETSEL sci_find $(findflags) `\"` previous example additionally demonstrates technique adding new-line character '\\n' text. uses NppExec's function strfromhex get Unicode two-byte character '\\n' hexadecimal representation 0A 00 ( lower bytes goes first, upper bytes goes next). This equal : set local newline ~ chr 0x0A // '\\n' character Similarly, tabulation character '\\t' obtained : set local tab ~ chr 0x09 // '\\t' character echo ab$(tab)cd Here example that takes %PATH% environment variable represents multi-line string by replacing all ';' with '\\n': npp_console local - set local n ~ chr 0x0A // '\\n' set local s ~ strreplace \"$(SYS.PATH)\" ; $(n) npp_console local + echo $(s)  strfromhex more powerful than chr since strfromhex allows operate with sequence bytes while chr limited one character. example, Windows uses '\\r\\n' line endings that consist two characters '\\r' '\\n'. These two characters represented by 4 bytes Unicode two-byte character string: set local newline ~ strfromhex 0D 00 0A 00 // '\\r\\n' characters '\\r' 0D 00 '\\n' 0A 00 here. Here example that uses strunescape construct multi-line message: set local msg ~ strunescape Drive1 C:\\\\\\nDrive2 D:\\\\ messagebox `$(msg)` also: Calculations, strlen .",
    "path": "./3.8.5.html"
  },
  "4. Advanced usage": {
    "content": "4. Advanced usage",
    "path": "./4.html"
  },
  "4.0. Introduction to compiling/interpreting/etc.": {
    "content": "4.0. Introduction compiling/interpreting/. starting read compiling/interpreting, should know that programmers usually count 0 instead 1 -- that's why number this section 4.0 instead 4.1 :) let's proceed. , compile run something using NppExec. Great, that's purpose this plugin. , before start , must understand principles NppExec. Let's refer section this manual: NppExec compiler. NppExec allows use external tools compilers process/compile current file, ability by itself. magic here :) This basic idea advanced usage NppExec. Whatever source file compile run - whether C, C++, Java, Python, Perl, ., . - always need specify two things: compile run ( source file itself); WHO will ( interpreter compiler). If specify only compile run, NppExec will tell system exactly same: run this file. system most likely will answer: know how run this file. If specify only WHO will , NppExec will run specified interpreter/compiler - will interpret/compile anything because did specify interpret compile. Let's repeat again: NppExec itself know anything source file make assumptions regarding . NppExec just exactly tell - that's all. OK, may ask: why, example, when m double-clicking my GhostScript file ( NSIS file, Python file, JavaScript file, whatever) Windows Explorer, becomes executed - happen NppExec? system seems know how run file, right? - why isn't executed within NppExec? answer simple: double-clicking file Windows Explorer same trying run this file directly. Let me explain: when double-click file, Windows Explorer tries run using system file associations. example, when double-click .doc .docx file, Windows Explorer detects that this file associated with Microsoft Office - asks Microsoft Office open this file. same , if Python files associated with Python IDE, Windows Explorer will try run open these file using Python IDE. other , when NppExec run file, tells system: run this file if executed by itself (without associated program). That's difference. system file associations used this case. NppExec also ability run file using system file associations. m talking \"NPP_RUN <file>\". this case NppExec will tell system: run this file using system file associations. will have same effect double-clicking Windows Explorer. very same effect - will have output NppExec's Console because file will executed inside Console this case. Refer section more details. Now guess time rephrase basic idea advanced usage NppExec: run source file NppExec's Console, always need specify two things. first thing compile run ( source file itself). second thing WHO will ( interpreter compiler). Let's name thing <file> (because source file) WHO thing <tool> (because tool which will interpret compile file). According this, need specify following generic command interpret/compile/run source file: <tool> <file> <arguments> We have one additional thing here: <arguments>. This thing refers tool-specific command-line arguments which may ( may ) needed interpret/compile/run source file. 't give more information here because this part really differs different compilers/interpreters. need read compiler/interpreter's documentation regarding this. cases may need specify additional arguments before source file name: <tool> <arguments> <file> Phew! long far, isn't ? ;) let's proceed. Now already have ( least hope ) general vision regarding 's needed interpret/compile/run source file. Let's take into account one more thing: NppExec cmd.exe. NppExec allows run something console output, system's command interpreter (cmd.exe) itself invoke cmd.exe if did call explicitly. (Note: NppExec ver. 0.6 RC3 introduces new advanced option \"ChildProcess_RunPolicy\" that allows modify this behavior. Refer more details.) Thus may encounter different behaviour NppExec's Console system's console (cmd.exe). Refer section more details. Anyway, \"ask\" cmd.exe something by calling NppExec explicitly. Refer section more details. , 's next? Did tell everything need there something left? Maybe, enough talking - let's examples? Yes, let's have practice. , NppExec something. open NppExec's Console type: \"something\". Then press Enter. Here Console: something CreateProcess() failed with error code 2: system find file specified. hell happened? Help! Let's analyze. tried run \"something\". \"something\"? seems executable file because specified without extension. have result? have \" system find file specified\". , nothing magical: tried run file which exist. Let me write comments here. When type \"something\" press Enter, means following: run executable file \"something\" (\"something.exe\") current directory directory mentioned %PATH%. This system tries . if have \"something.exe\" current directory somewhere %PATH%, this file (\"something.exe\") will executed will have error code 2. have very same error when name executable specified incorrectly. example: %systemroot%\\notepad.exe CreateProcess() failed with error code 2: system find file specified. hell happened? Help! already wrote, NppExec cmd.exe. mean? means that NppExec, particular, know %systemroot%. cmd.exe knows , right? type following: cmd /c %systemroot%\\notepad.exe Notepad will run by cmd.exe (while cmd.exe itself executing NppExec). hope these basic examples were useful, our goal compile/interpret/run something, isn't ? we example something like \"<tool> <file> <arguments>\", we? OK, let's take source file try run . said, we could take source file - matter language using. , just example purposes, let's assume we have .awk file with following text: BEGIN { print \"Hello!\" } Did hear something AWK know something ? ? That's great, because NppExec also ! Now repeat: matter language using - could Pascal, Java, PHP, Ruby , - principle remains same. NppExec know anything this language make assumptions regarding . should exactly specify interpret/compile/run ( source file) WHO will ( interpreter/compiler). , we assuming we have opened file \"program.awk\" with following text: BEGIN { print \"Hello!\" } we run . Right now we able specify we run: our source file \"program.awk\". Notepad++ NppExec provide following variables which contain current file name: $(FULL_CURRENT_PATH) : full pathname current file Notepad++ $(FILE_NAME) : name extension current file Notepad++ Now, if type \"$(FULL_CURRENT_PATH)\" press Enter NppExec's Console, will something like following: $(FULL_CURRENT_PATH) C:\\Documents Settings\\User\\My Documents\\program.awk CreateProcess() failed with error code 193 If search Google ( Bing, whatever) \"error code 193\", will find following description: \"%1 valid Win32 application\". This exactly we have discussed before: system know how run this file. , our responsibility specify valid compiler/interpreter which able run . our case .awk file, we should use ether GAWK AWK95 interpreter. ( case another file -- such .cpp, .java, .php -- should use appropriate compiler/interpreter.) Let's assume have downloaded latest GAWK package unpacked \"C:\\tools\\GAWK\". path GAWK executable \"C:\\tools\\GAWK\\gawk.exe\". Let's try run without parameters: C:\\tools\\GAWK\\gawk.exe Process started >>> Usage: gawk [POSIX GNU style options] -f progfile [--] file ... (...) <<< Process finished. , we ? We that we should specify \"-f\" between \"gawk.exe\" .awk source file. Now let's try run our file: C:\\tools\\GAWK\\gawk.exe -f $(FULL_CURRENT_PATH) C:\\tools\\GAWK\\gawk.exe C:\\Documents Settings\\User\\My Documents\\program.awk Process started >>> gawk: fatal: 't open source file `C:\\Documents' reading ( such file directory) <<< Process finished. hell happened? Help! Well. If we look file pathname \"C:\\Documents Settings\\User\\My Documents\\program.awk\", we observe spaces there. mean? According default system behaviour, ALL file names with spaces should enclosed double quotes. Otherwise system understand where end file name treats spaces dividers between several file names. , let's try again: \"C:\\tools\\GAWK\\gawk.exe\" -f \"$(FULL_CURRENT_PATH)\" \"C:\\tools\\GAWK\\gawk.exe\" -f \"C:\\Documents Settings\\User\\My Documents\\program.awk\" Process started >>> Hello! <<< Process finished. Success! We have successfully run our .awk program using gawk.exe. This illustrates our general principle which could applied language: specify run ( source file) WHO will run ( interpreter compiler). Additional argument (\"-f\" our case) included. path interpreter also enclosed double quotes because, general, also may contain spaces. Thus d recommend always enclose paths interpeter/compiler source file double quotes. Phew!.. still here, with me? ;) else say?.. much, actually. Often better write NppExec's script running/compiling purposes, because lot actions (commands) may required this. several examples under sections  . here one more useful advice. Starting NppExec v0.4.2, use run-time variables command aliases. example, define following alias: npe_cmdalias g = \"C:\\tools\\GAWK\\gawk.exe\" -f \"$(FULL_CURRENT_PATH)\" Once did , type just \"g\" run current file using gawk.exe. Type \"help npe_cmdalias\" NppExec's Console learn more command aliases.",
    "path": "./4.0.html"
  },
  "4.1. NppExec's Console behaviour": {
    "content": "4.1. NppExec's Console behaviour By default, NppExec's Console automatically shown each time execute NppExec's script. reason simple: usually script execution assumes output which needed least may usefull user. However, may scripts executed silently (.e. without showing NppExec's Console) even force NppExec's Console closed. NppExec allows this using command NPP_CONSOLE. use NPP_CONSOLE ? beginning script order keep current Console's state. means that hidden (closed) Console remains hidden shown (opened) Console remains shown. Also use NPP_CONSOLE 0 hide Console, NPP_CONSOLE 1 show Console during script execution. Type \"help npp_console\" NppExec's Console more details. By default, NppExec's Console automatically cleared each time execute NppExec's script. However, use NPE_CONSOLE + enable \"append\" mode which keeps previous Console's text clear . Type \"help npe_console\" NppExec's Console more details. set keyboard focus NppExec's Console, use NPP_SETFOCUS Con Type \"help npp_setfocus\" NppExec's Console more details. By default, when \"Toggle NppExec Console\" (Ctrl+~) switches NppExec's Console Notepad++'s editing window, Console remains visible. If NppExec's Console become hidden when switching Notepad++'s editing window, following: NppExec's Console, press Ctrl+F F7 show search pane; search pane, check \"Hide toggled Console\". also: NppExec's Console ; Console output redirection .",
    "path": "./4.1.html"
  },
  "4.2. Environment": {
    "content": "4.2. Environment NppExec allows specify environment (.e. environment variables) program start NppExec. NppExec's scripts directly NppExec's Console window. set remove/restore such environment variables using NppExec's commands ENV_SET ENV_UNSET. example, set own value PATH: ENV_SET PATH = C:\\temp // modified Now start cmd.exe ( NppExec's script NppExec's console) type \"echo %PATH%\" ensure that value PATH now \"C:\\temp\". Type \"exit\" exit cmd.exe then execute this NppExec's command: ENV_UNSET PATH // restored This command restores initial value PATH. NppExec remove PATH variable because this variable existed before modified with ENV_SET. same time, create remove new environment variables: ENV_SET new_environment_variable = Hello // created ENV_UNSET new_environment_variable // removed Such environment variables used ( modified) by program start NppExec. Also, values such variables used by NppExec form $(SYS.variable_name). example: ENV_SET = My Variable // created: =My Variable echo $(SYS.) // prints: My Variable ENV_SET = aaa // modified: =aaa echo $(SYS.) // prints: aaa ENV_UNSET // removed .e. use \"$(SYS.variable_name)\" read variable's value use \"ENV_SET variable_name = value\" set variables's value. If there need set/modify environment variable temporarily ( scope current NppExec's script), use \"ENV_SET local <var> = <value>\". Once current NppExec's script ends, previous value <var> restored automatically. Type \"help env_set\" NppExec's Console more details. Good set environment inside NppExec's start-up script. specify start-up script NppExec's Advanced Options. This script will executed each time Notepad++ starts. example, create similar script: // show NppExec's Console if hidden NPP_CONSOLE ? // output anything within this NppExec's script NPP_CONSOLE local - // we output anything, print \"==== READY ====\" NPE_CONSOLE local -- p- // set our environment variables ENV_SET NPPHOME = $(NPP_DIRECTORY) ENV_SET TCCHOME = C:\\tools\\tcc // restore initial value PATH ENV_UNSET PATH // set our value PATH ENV_SET PATH = $(SYS.NPPHOME);$(SYS.TCCHOME);$(SYS.PATH) // clear Console screen CLS first command (\"NPP_CONSOLE ?\") forbids Console shown if hidden - this usefull Notepad++'es start-up. next command (\"NPP_CONSOLE local -\") disables output Console within current NppExec's script, thus making script completely silent. next command (\"NPE_CONSOLE local -- p-\") disables \"==== READY ====\" message within current NppExec's script, this message printed when script finished. two following commands set new environment variables: NPPHOME TCCHOME. These environment variables used by program start NppExec. following command (\"ENV_UNSET PATH\") restores initial value PATH if previously been modified by NppExec. course, modified by NppExec before start-up script executed, may execute start-up script again (using NPP_EXEC \"Execute NppExec Script...\" dialog), may important restore initial value PATH before modifying . Otherwise, value PATH may grow again again - each time call start-up script explicitly execute another script which modifies PATH variable. next command sets new value PATH variable. Now PATH includes both NPPHOME TCCHOME, type just \"notepad++\" \"tcc\" order use Notepad++'es command line switches run tcc. Finally, last command (\"CLS\") clears NppExec's Console's output, Console will contain text when open . also: Environment (heritable) variables .",
    "path": "./4.2.html"
  },
  "4.3. Run-time parameters": {
    "content": "4.3. Run-time parameters NppExec supports several different use run-time parameters which vary according needs. first line each section below shows how run-time parameter(s) set, second line shows how these parameters used. Passing parameters NppExec's script ( use them inside script): NPP_EXEC \"my script\" \"param 1\" \"param 2\" -> $(ARGV), $(ARGV[1]), $(ARGV[2]), ... Run-time input (sets NppExec's variable $(INPUT) ): INPUTBOX \"Input value:\" : \"default value\" -> $(INPUT), $(INPUT[1]), $(INPUT[2]), ... User's variables (internal NppExec's variables): SET variable = value -> $(variable) Environment variables ( modified also outside NppExec) ENV_SET variable = value -> $(SYS.variable) also: User (internal) variables ; Environment (heritable) variables .",
    "path": "./4.3.html"
  },
  "4.4. Using cmd.exe": {
    "content": "4.4. Using cmd.exe NppExec by itself support standard console commands such \"copy\", \"move\", \"mkdir\", \"\" . (*) Actually, these commands part system's command interpreter (cmd.exe). , use cmd.exe perform such commands. example, type following commands NppExec's Console inside NppExec's script: // create directory C:\\Backup cmd /c mkdir C:\\Backup // save current Notepad++'es file NPP_SAVE // copy current file C:\\Backup cmd /c copy \"$(FULL_CURRENT_PATH)\" \"C:\\Backup\\$(FILE_NAME)\" /Y // change current directory cd C:\\Backup // list all .txt files C:\\Backup cmd /c %f (*.txt) @echo %f NppExec by itself redirect console program's output into text file. (*) , again, via cmd.exe: cmd /c program.exe >program.txt even cmd /c /? >.txt By , cmd.exe allows execute several commands one after another while each previous command completed successfully. example: cmd /c /? >.txt && type .txt cmd /c C: && cd C:\\Backup && %f (*.txt) @echo %f always type cmd /? more details cmd.exe commands. ll surprised how powerful :) forget execute .bat .cmd files same executable files - file extension (.bat .cmd) omitted this case. (*) batch files (.bat .cmd) allow implement sequences commands with simple algorithms, use them when single cmd's commands enough. (*) Starting NppExec ver. 0.6 RC3, possible execute batch files (such .bat .cmd) without specifying their extension, well possible avoid explicit usage \"cmd /C\" execute command interpreter's commands. new advanced option \"ChildProcess_RunPolicy\" introduced this. Set value 1  2 according desired behavior. Refer \"doc\\NppExec\\NppExec_TechInfo.txt\" further details. Finally, few words Delayed Expansion ( https://ss64.com/nt/delayedexpansion.html ). According cmd's help, this option turned by specifying cmd /V: Here example running batch file that relies Delayed Expansion (thus using /V:). This example assumes that current document batch file (thus using \"$(FULL_CURRENT_PATH)\") run own separate console window (thus using NPP_RUN): NPP_RUN cmd /V: /C \"$(FULL_CURRENT_PATH)\" also: something (how-) ; Console output redirection ; Grab date & time NppExec variable ; Run terminate PowerShell process ; Send several commands external tool .",
    "path": "./4.4.html"
  },
  "4.5. Console output redirection": {
    "content": "4.5. Console output redirection By default, when run console program using NppExec, program's output shown NppExec's Console. possible because console program started child process NppExec. NppExec uses pipes redirect child process'es output NppExec's Console window redirect user's input NppExec's Console window child process'es input. Such approach several known limitations: - output may shown until child process ends (if this child process performs lot operations without explicit flushing output); - output may shown while child process waits initial input (this may happen with interpreters, happen with cmd.exe); - stdout stderr output may mixed (stdout stderr redirected into same pipe); - output incorrect output may happen when child process requires \"real\" console screen buffer. advantages: + NppExec's Console supports ANSI (Windows), OEM (DOS) UTF-8 output input ( standard console usually supports just OEM ANSI); + NppExec's Console allows change console output using NppExec's Exclude/Include Replacing filters; + NppExec's Console allows highlight warnings/errors process them using NppExec's Highlight filters. If console program's output redirected into text file, use something similar following: cmd /c program.exe >C:\\temp\\.txt This will redirect output 'program.exe' into text file '.txt' inside 'temp' folder drive C (this folder must exist). Then open this text file Notepad++: NPP_OPEN C:\\temp\\.txt Thus, use following NppExec's script: SET local OUTFILE = C:\\temp\\.txt cmd /c program.exe >$(OUTFILE) NPP_OPEN $(OUTFILE) also: NppExec's Console ; NppExec's Console behaviour ; Using cmd.exe .",
    "path": "./4.5.html"
  },
  "4.6. Using external tools": {
    "content": "4.6. Using external tools",
    "path": "./4.6.html"
  },
  "4.6.1. Applying external tool to selected text": {
    "content": "4.6.1. Applying external tool selected text Let's suppose apply AWK program selected text Notepad++. first thing require NppExec plugin ;) second thing require AWK executable, example, \"awk95.exe\" \"gawk.exe\". When apply AWK program selected text, this AWK program must exists, isn't ? , create file \".awk\" Notepad++'s folder. full path this file \"$(NPP_DIRECTORY)\\.awk\". OK, file created, now need AWK program. Open \".awk\" Notepad++ type program, example: { print $0 } This simple AWK program will print each record (.e. text line) input file given. Now, open another file Notepad++ select text (few lines, example). Now have selected text tool (awk95.exe gawk.exe) apply this selected text. only thing remaining NppExec's script which will allow . Press F6 ( Plugins -> NppExec -> Execute NppExec Script...) type: // full path AWK executable set local AWK_EXE = C:\\tools\\awk\\awk95.exe // this temporary file name will used set local TEMP_FILE = $(SYS.TEMP)\\npp_sel.txt // save current selection ANSI text file SEL_SAVETO $(TEMP_FILE) : // run .awk this file \"$(AWK_EXE)\" -f \"$(NPP_DIRECTORY)\\.awk\" \"$(TEMP_FILE)\" Save this script \".awk selected text\" whatever . Press OK. will AWK's output NppExec's Console window. copy there with Ctrl+C. understand, such approach used command-line external tool such grep, php . Good luck! P.S. By , if have nothing selected select word under caret, following script used: // get current position... SCI_SENDMSG SCI_GETCURRENTPOS set local pos = $(MSG_RESULT) // get start word near pos... SCI_SENDMSG SCI_WORDSTARTPOSITION $(pos) 1 set local wordStart = $(MSG_RESULT) // get end word near pos... SCI_SENDMSG SCI_WORDENDPOSITION $(pos) 1 set local wordEnd = $(MSG_RESULT) // set selection SCI_SENDMSG SCI_SETSEL $(wordStart) $(wordEnd) If combine this script with previous one, will able apply external tool word under caret. (.e. first will select word under caret, then will apply external tool that selected word.) Also consider ability use $(CURRENT_WORD) instead SEL_SAVETO this case ( ). also: Processing & replacing selection ; Modify selected text save file .",
    "path": "./4.6.1.html"
  },
  "4.6.10. Running Lua": {
    "content": "4.6.10. Running Lua Depending exactly we achieve, here two NppExec's scripts that used run Lua: // Lua NppExec's Console set local Lua = C:\\Lua\\bin\\lua.exe // <-- specify path Lua here! npp_save // saves current .lua file \"$(Lua)\" \"$(FULL_CURRENT_PATH)\" // runs  // Lua separate console window set local Lua = C:\\Lua\\bin\\lua.exe // <-- specify path Lua here! npp_save // saves current .lua file npp_run cmd /c \"\"$(Lua)\" \"$(FULL_CURRENT_PATH)\" && pause\" // runs",
    "path": "./4.6.10.html"
  },
  "4.6.11. Clone current document to new editor pane": {
    "content": "4.6.11. Clone current document new editor pane Let's consider following scenario: copy entire content current document (opened Notepad++) paste new editor pane. first implementation that comes mind : save current position caret; select all text copy clipboard; restore position caret; open new editor pane paste text clipboard. Notepad++ uses Scintilla component handle text all text operations, let's deal directly with Scintilla implement all above. Let's refer Scintilla's documentation get idea how : https://www.scintilla.org/ScintillaDoc.html#SelectionAndInformation https://www.scintilla.org/ScintillaDoc.html#CutCopyAndPaste Looking documentation, we may end up with following NppExec script: // saving caret pos & anchor sci_sendmsg SCI_GETCURRENTPOS set local pos = $(MSG_RESULT) sci_sendmsg SCI_GETANCHOR set local anchor = $(MSG_RESULT) // selecting all sci_sendmsg SCI_SELECTALL // copying selection clipboard sci_sendmsg SCI_COPY // restoring caret pos & anchor sci_sendmsg SCI_SETSEL $(anchor) $(pos) // open new editor pane NPP_SENDMSG WM_COMMAND IDM_FILE_NEW // pasting text clipboard sci_sendmsg SCI_PASTE Inspecting Scintilla's documentation further, we notice SCI_COPYRANGE that allows simplify entire script: // getting length document sci_sendmsg SCI_GETTEXTLENGTH set local textlength = $(MSG_RESULT) // copying entire text clipboard sci_sendmsg SCI_COPYRANGE 0 $(textlength) // open new editor pane NPP_SENDMSG WM_COMMAND IDM_FILE_NEW // pasting text clipboard sci_sendmsg SCI_PASTE Looking into \"Notepad_plus_msgs.h\" (\"PowerEditor\\src\\MISC\\PluginsManager\\Notepad_plus_msgs.h\"), we implement advanced version this script that: applies encoding current document new one; applies language (such C++, JavaScript, XML, .) current document new one; sets same caret anchor positions current document. Here final NppExec's script: // getting current buffer id npp_sendmsg NPPM_GETCURRENTBUFFERID set local originalBufferId = $(MSG_RESULT) // getting current buffer encoding & lang type npp_sendmsg NPPM_GETBUFFERENCODING $(originalBufferId) set local bufEnc = $(MSG_RESULT) npp_sendmsg NPPM_GETBUFFERLANGTYPE $(originalBufferId) set local bufLangType = $(MSG_RESULT) // getting caret pos & anchor sci_sendmsg SCI_GETCURRENTPOS set local pos = $(MSG_RESULT) sci_sendmsg SCI_GETANCHOR set local anchor = $(MSG_RESULT) sci_sendmsg SCI_GETFIRSTVISIBLELINE set local firstvisibleline = $(MSG_RESULT) // getting length document sci_sendmsg SCI_GETTEXTLENGTH set local textlength = $(MSG_RESULT) // copying entire text clipboard sci_sendmsg SCI_COPYRANGE 0 $(textlength) // opening new editor pane (new document) NPP_SENDMSG WM_COMMAND IDM_FILE_NEW // getting new buffer id npp_sendmsg NPPM_GETCURRENTBUFFERID set local newBufferId = $(MSG_RESULT) // setting new buffer encoding & lang type npp_sendmsg NPPM_SETBUFFERENCODING $(newBufferId) $(bufEnc) npp_sendmsg NPPM_SETBUFFERLANGTYPE $(newBufferId) $(bufLangType) // pasting text clipboard sci_sendmsg SCI_PASTE // setting caret pos & anchor sci_sendmsg SCI_SETSEL $(anchor) $(pos) sci_sendmsg SCI_SETFIRSTVISIBLELINE $(firstvisibleline) Note: this last script, originally thinking use SCI_GETCODEPAGE SCI_SETCODEPAGE deal with text encoding. appeared that Notepad++ seem aware encoding change by SCI_SETCODEPAGE. ve used Notepad++'s dealing with encoding via NPPM_GETBUFFERENCODING NPPM_SETBUFFERENCODING.",
    "path": "./4.6.11.html"
  },
  "4.6.12. Passing multiple files to external tool": {
    "content": "4.6.12. Passing multiple files external tool Sometimes may pass multiple files external tool, especially when these multiple files part project external tool compiler that compiles this project. Usually makefile created these purposes, path makefile passed compiler. let's imagine we use makefile use NppExec's script this. Let's say we NppExec's script look through files opened Notepad++ create list files with given file extension. example, following NppExec's scripts collects all opened files with .cpp extension outputs them NppExec's Console: npp_console local - // disable output Console set local MatchExt = .cpp // file extension match set local FileList = // output file list set local = 1 // iterating through all opened files... :NextOpenedFile set local file = $(#$()) // full path name if \"$(file)\" == \"\" goto OutOfOpenedFiles set local n ~ strrfind \"$(file)\" \\ if n == -1 then set local n ~ strrfind \"$(file)\" / endif if n != -1 then set local n ~ $(n) + 1 set local file ~ substr $(n) - $(file) // file name (without path) endif set local n ~ strrfind \"$(file)\" . if n != -1 then set local e ~ substr $(n) - $(file) // file extension if \"$(e)\" ~= \"$(MatchExt)\" then // compare case-insensitively set local FileList = $(FileList) \"$(file)\" endif endif set local ~ $() + 1 goto NextOpenedFile :OutOfOpenedFiles npp_console local + // enable output Console echo $(FileList) If project consists lot files, including files subfolders, we may form list all these files using additional tool such Swiss File Knife ( https://sourceforge.net/projects/swissfileknife/files/ ). Here how Swiss File Knife (sfk) creates list all .cpp files starting current directory: sfk list -quot -dir . -file .cpp +xed \"/[xwhite]/ /\" Then, using sfk, NppExec's script will look like following: npp_console local - // disable output Console set local MatchExt = .cpp // file extension match npe_console local v+ sfk list -quot -dir . -file $(MatchExt) +xed \"/[xwhite]/ /\" set local FileList = $(OUTPUTL) npp_console local + // enable output Console echo $(FileList) only thing remaining call compiler passing $(FileList) . example: g++ -c $(FileList) also: Compiling .",
    "path": "./4.6.12.html"
  },
  "4.6.13. Working with the Notepad++ 'Replace' dialog": {
    "content": "4.6.13. Working with Notepad++ 'Replace' dialog Let's imagine invoke Notepad++ 'Replace' dialog, populate 'Find ' 'Replace with' fields with specific strings, check uncheck search-related checkboxes, finally press 'Find Next' button. all this programmatically. first tools that come my mind such things AutoIt ( https://www.autoitscript.com/ ) AutoHotKey ( https://www.autohotkey.com/ ). let's consider something simpler. example, NirCmd NirSoft ( https://www.nirsoft.net/ ). First, let's create following NppExec script: env_set local PATH = $(SYS.PATH);C:\\tools\\NirSoft // TODO: specify path folder with nircmd.exe here! npp_sendmsg WM_COMMAND IDM_SEARCH_REPLACE // showing Replace dialog nircmd script \"$(NPP_DIRECTORY)\\replace.ncl\" // TODO: may specify other folder than $(NPP_DIRECTORY) Then, NppExec script above mentions \"$(NPP_DIRECTORY)\\replace.ncl\", let's create file named \"replace.ncl\" under Notepad++ folder. will simple non-Unicode text file with following lines: // set 'Find ' text: dlg \"notepad++.exe\" \"Replace\" settext 1601 \"Find \" // set 'Replace with' text: dlg \"notepad++.exe\" \"Replace\" settext 1602 \"Replace with\" // uncheck 'Whole word' checkbox: win child title \"Replace\" sendmsg id 1603 0x00F1 0x0000 0 // uncheck 'Match case' checkbox: win child title \"Replace\" sendmsg id 1604 0x00F1 0x0000 0 // check 'Wrap around' checkbox: win child title \"Replace\" sendmsg id 1606 0x00F1 0x0001 0 // uncheck 'Backward direction' checkbox: win child title \"Replace\" sendmsg id 1722 0x00F1 0x0000 0 // click 'Regular expression' button: win child title \"Replace\" sendmsg id 1605 0x00F5 0 0 // uncheck '. matches newline' checkbox: win child title \"Replace\" sendmsg id 1703 0x00F1 0x0000 0 // click 'Find Next' button: win child title \"Replace\" sendmsg id 1 0x00F5 0 0 This file uses hard-coded string \"Replace\" title Notepad++ 'Replace' dialog. If using non-English localization, will need replace word \"Replace\" with localization-dependent title (such \"Remplacer\" French). Also, this file uses several magic numbers such 1601 1602, 0x00F1 0x00F5, 0x0000 0x0001. Let me explain they mean. deal with controls (elements) dialog, we need know corresponding control identifiers (control IDs). Here we inside Notepad++ source file https://github.com/notepad-plus-plus/notepad-plus-plus/blob/master/PowerEditor/src/ScintillaComponent/FindReplaceDlg_rc.h : #define IDFINDWHAT 1601 #define IDREPLACEWITH 1602 #define IDWHOLEWORD 1603 #define IDMATCHCASE 1604 #define IDREGEXP 1605 #define IDWRAP 1606 believe this explains where magic numbers 1601, 1602, , came . These control IDs. Another get these IDs use specific program such Property Edit ( https://mh-nexus.de/en/downloads.php?product=Property%20Edit ). Now, knowing control IDs, we send specific messages these controls. BM_SETCHECK message responsible checking/unchecking checkbox control; BM_CLICK message responsible clicking button. When we look inside Windows header file, \"winuser.h\", we that BM_SETCHECK defined 0x00F1 BM_CLICK defined 0x00F5. Finally, values 0x0000 0x0001 this context parameters BM_SETCHECK (0x00F1) message. Their meanings with respect BM_SETCHECK message : 0x0000 BST_UNCHECKED 0x0001 BST_CHECKED. , \"0x00F1 0x0001 0\" checks checkbox control, whereas \"0x00F1 0x0000 0\" unchecks . may read more here: https://docs.microsoft.com/windows/win32/controls/bm-setcheck Important note: NppExec's scripts executed separate thread, script continues execution when Notepad++'s dialog shown. allows use NirCmd ( well AutoHotKey other tool) interact with Notepad++'s dialog by pressing buttons . Correspondingly, also possible close dialog then execute other commands same NppExec's script. Now, after warming up, let's create similar AutoHotKey script. AutoHotKey provides more abilities more control over we doing, recommended. We will use AutoHotKey 2.0 (refer https://www.autohotkey.com/docs/v2/v2-changes.htm details). new NppExec script invoke AutoHotKey will quite similar one that invokes NirCmd. We will additionally pass handle Notepad++ main window input parameter .ahk script. This ensure that we will dealing with current Notepad++ window ( there may other running instances Notepad++): set local AutoHotKeyDir = C:\\tools\\AutoHotKey // TODO: specify path AutoHotKey folder here! env_set local PATH = $(SYS.PATH);$(AutoHotKeyDir) // adding %PATH% npp_sendmsg WM_COMMAND IDM_SEARCH_REPLACE // showing Replace dialog AutoHotkey32.exe \"$(AutoHotKeyDir)\\NppReplace.ahk\" $(NPP_HWND) // TODO: may place .ahk script under different folder Now, let's write .ahk script that will all magic. Let's create file named \"NppReplace.ahk\" under folder specified NppExec script above ( this example, \"$(AutoHotKeyDir)\\NppReplace.ahk\"). This file uses AutoHotKey 2.0 syntax: if A_Args.Length < 1 { MsgBox(\"Usage: \" A_ScriptName \" <NPP_HWND>\",, 0x30) ; 0x30 - exclamation Exit } ReplaceDlgTitle := \"Replace\" idNppWnd := Integer(A_Args[1]) idReplaceDlg := 0 idDlgList := WinGetList(ReplaceDlgTitle \" ahk_exe notepad++.exe\") idDlg idDlgList { idParent := DllCall(\"user32\\GetParent\", \"Ptr\", idDlg, \"Ptr\") if idParent = idNppWnd { idReplaceDlg := idDlg break } } if idReplaceDlg = 0 { MsgBox(\"Could find dialog with title `\"\" ReplaceDlgTitle \"`\" NPP_HWND=\" Format(\"0x{:X}\", idNppWnd),, 0x10) ; 0x10 - error Exit } GetDlgItem(idDlg, idItem) { return DllCall(\"user32\\GetDlgItem\", \"Ptr\", idDlg, \"\", idItem, \"Ptr\") } ClickButton(idButton) { SendMessage(0x00F5, 0, 0, idButton) } idFindWhat := GetDlgItem(idReplaceDlg, 1601) idReplaceWith := GetDlgItem(idReplaceDlg, 1602) idWholeWord := GetDlgItem(idReplaceDlg, 1603) idMatchCase := GetDlgItem(idReplaceDlg, 1604) idWrapAround := GetDlgItem(idReplaceDlg, 1606) idBackwardDirection := GetDlgItem(idReplaceDlg, 1722) idRegularExpression := GetDlgItem(idReplaceDlg, 1605) idDotMatchesNewline := GetDlgItem(idReplaceDlg, 1703) idFindNext := GetDlgItem(idReplaceDlg, 1) ControlSetText(\"Find \", idFindWhat) ControlSetText(\"Replace With\", idReplaceWith) ControlSetChecked(0, idWholeWord) ControlSetChecked(0, idMatchCase) ControlSetChecked(1, idWrapAround) ControlSetChecked(0, idBackwardDirection) ClickButton(idRegularExpression) ControlSetChecked(0, idDotMatchesNewline) ClickButton(idFindNext) Exit Note: If find replace string programmatically without showing Replace dialog , NppExec proposes following commands this: SCI_FIND SCI_REPLACE. actual behavior these commands completely depend <flags> parameter specified. description examples available by typing following: help sci_find help sci_replace help all also: Clipboard, keystrokes much more .",
    "path": "./4.6.13.html"
  },
  "4.6.14. Notepad++ as a Clipboard Monitor": {
    "content": "4.6.14. Notepad++ Clipboard Monitor Let's imagine Notepad++ work Clipboard Monitor by gathering all text copied Clipboard into single file shown Notepad++. We may use third-party tool such AutoHotKey all clipboard-related work, while Notepad++'s work will automatically refresh file content once text Clipboard been added this file. first, let's download install AutoHotKey v2 ( https://www.autohotkey.com/ ). Secondly, let's write AutoHotKey v2 script that will monitor Clipboard append new text data single file. Let's accept path that single file input argument script: #SingleInstance Force if A_Args.Length < 1 { MsgBox \"This script requires path output text file argument!\" ExitApp } ; TempDir := EnvGet(\"TEMP\") ; ClpbrdFilePath := TempDir \"\\clpbrd.txt\" ClpbrdFilePath := A_Args[1] ; reading file path command-line argument FileObj := FileOpen(ClpbrdFilePath, \"w\") ; creating empty file FileObj.Close() OnClipboardChange ClipboardChanged ; clipboard callback function ClipboardChanged(DataType) { if DataType = 1 { ; text FileObj := FileOpen(ClpbrdFilePath, \"\") FileObj.WriteLine(A_Clipboard) ; appending file FileObj.Close() ; ToolTip \"Clipboard text: '\" A_Clipboard \"'\" ; Sleep 2000 ; ToolTip ; Turn tip. } } ProcessWaitClose(\"notepad++.exe\") ; active while Notepad++ active ExitApp Let's save this script file e.g. \"C:\\AutoHotkeyScripts\\NppClipboardMonitor.ahk\". Now let's write NppExec's script that will use AutoHotKey v2 script mentioned above. (If have NppExec plugin, install via Plugins -> Plugins Admin... first). Notepad++, select Plugins -> NppExec -> Execute NppExec Script... type following opened dialog: npp_console ? set local cbfile = $(SYS.TEMP)\\clpbrd.txt set local ah2script = C:\\AutoHotkeyScripts\\NppClipboardMonitor.ahk npp_run \"C:\\Program Files\\AutoHotkey\\v2\\AutoHotkey32.exe\" \"$(ah2script)\" \"$(cbfile)\" npp_close \"$(cbfile)\" npp_open \"$(cbfile)\" npp_menucommand View|Monitoring (tail -f) This assumes AutoHotKey v2 installed \"C:\\Program Files\\AutoHotkey\\v2\" Notepad++'s interface uses English localization. If Notepad++'s localization different than English, please change line npp_menucommand View|Monitoring (tail -f) one corresponding Notepad++'s localization. Alternatively, use npp_sendmsg NPPM_SETMENUITEMCHECK IDM_VIEW_MONITORING 1 enable monitoring, npp_sendmsg NPPM_SETMENUITEMCHECK IDM_VIEW_MONITORING 0 disable monitoring. Let's save NppExec's script above \"clipboard monitor\". , press \"Save...\" button, type \"clipboard monitor\" (without quotes) press \"Save\". Now may assign shortcut key this NppExec's script. that, select Plugins -> NppExec -> Advanced Options... click \"Associated script:\" combo-box bottom part opened dialog. Select \"clipboard monitor\" item drop-down list press \"/Modify\". new item \"clipboard monitor :: clipboard monitor\" will added \"Menu items\" list. When finally press \"OK\", there will message \"Notepad++ must restarted apply options\". This required new menu item \"clipboard monitor\" Notepad++. When Notepad++ restarted, shortcut key assigned new menu item \"clipboard monitor\". Notepad++, select Settings -> Shortcut Mapper... click \"Plugin commands\". Find \"clipboard monitor\" command that corresponds \"NppExec.dll\" assign desired shortcut key . Everything ready! Now either press shortcut key assigned \"clipboard monitor\" menu item select Plugins -> NppExec -> Execute NppExec Script... then select \"clipboard monitor\" combo-box bottom opened dialog finally press \"OK\". ll empty file \"clpbrd.txt\" opened Notepad++. Now, copy text Clipboard program - that exact text should appended \"clpbrd.txt\" file content shown Notepad++. Final words. If close / reopen this file ( \"clpbrd.txt\" one) Notepad++ if restart Notepad++, forget run \"clipboard monitor\" NppExec's script again order monitor Clipboard. Otherwise \"clpbrd.txt\" will simple text file. (Because fact  simple text file). we discussed above, all clipboard monitoring work done by AutoHotKey. Correspondingly, when AutoHotKey v2 script running, may find AutoHotKey's icon TaskBar, well right-click that icon select \"Exit\" exit AutoHotKey. such case, ll again have run \"clipboard monitor\" NppExec's script manually order monitor Clipboard. magic here, just dexterous :-) also: Clipboard, keystrokes much more .",
    "path": "./4.6.14.html"
  },
  "4.6.15. Triggering certain actions while saving a file": {
    "content": "4.6.15. Triggering certain actions while saving file Probably already thought that: how useful would if NppExec allowed trigger certain actions each time file saved. example, might external spell-checker run text files; code-formatting tool run certain source files; also, might backups other files; . applications provide callback mechanisms triggers similar purpose. example, there could \"OnSave\" callback/trigger that invoked/triggered each time file saved. NppExec provide that, mostly because good avoid deadlocks / infinite recursion. Here example latter: let's imagine we have certain \"OnSave\" script triggered each time file saved. Now, let's imagine this \"OnSave\" script contains command NPP_SAVE NPP_SAVEALL. This embedded command will trigger another \"OnSave\" script, which, turn, will execute another NPP_SAVE NPP_SAVEALL, forth. Here different example: let's imagine \"OnSave\" script starts long-running external process, such \"cmd.exe\" without arguments. By nature, NppExec will wait until this process finished - will happening while saving file. , m saying implement this - all m saying there certain problems which good solution yet. Anyway, let's look we right now. always, NppExec allows much more than expected, come ---box - we rather have everything manually. Well, let's ! :-) first, let's alternative callback/trigger. may look obvious - let's concentrate we usually save file manually. We basically have two options that: either press \"Save\" button Toolbar press Ctrl+S. latter, Ctrl+S, one we going use. (Well, m aware auto-saving feature - if rely , m encouraging use Ctrl+S because, well, because required all further steps this instruction :-) ). basic idea this: if we assign Ctrl+S certain NppExec's script rather than internal Notepad++'s \"Save File\" command? once we have thought that, solution immediately seen! Step one: create NppExec's script that will handling file saving operation. Step two: create menu item this NppExec's script. Step three: assign shortcut Ctrl+S that menu item. Voila! , let's implement that step by step. Let's start very simple NppExec's script, such this one: // npp_console ? npp_console local - npe_console local m- -- npp_console local + echo Before saving file \"$(FULL_CURRENT_PATH)\" npp_save // saving file echo After saving file \"$(FULL_CURRENT_PATH)\" We intentionally use \"npe_console local m- --\" beginning script make less verbose. script may grow with time, pretty good idea abridge output. This simple script prints one message before file saved another message after file saved. purpose this script executed Ctrl+S, let's consider would happen if we removed \"npp_save\" command. Right, file would have never saved! Let's keep that mind. OK, let's save this script with name \"file_save\". ( assume already familiar with \"Execute NppExec Script...\" dialog NppExec's script ). step one (mentioned above) done: script been created! Let's proceed step two. Notepad++'s main menu, select Plugins -> NppExec -> Advanced options... Now, Advanced Options dialog, click \"Associated script\" combo-box, select \"file_save\" there click \"/Modify\" button. ll new item \"file_save :: file_save\" \"Menu items\" list. Now press \"OK\" - ll message \"Notepad++ must restarted apply options\". This required new menu item \"file_save\" Notepad++. , let's restart Notepad++. This will finish step two. After Notepad++ restarted, shortcut key assigned new menu item \"file_save\". This step three. Notepad++, select Settings -> Shortcut Mapper... click \"Plugin commands\". Find \"file_save\" command that corresponds \"NppExec.dll\" try assign Ctrl+S . will : \"CONFLICT FOUND! Main menu | Save ( Ctrl + S )\". Oops! Looks like we need disable this shortcut standard command first. OK, let's click \"Main menu\" tab, find \"Save | Ctrl+S\" there, select press \"Modify\". Let's assign non-used shortcut : example, Ctrl+Alt+Shift+S whatever like unless conflicts with existing shortcut. After this done, let's return \"find_save\" command \"Plugin commands\" tab assign Ctrl+S . step three done! Now let's test we accomplished. Once press Ctrl+S file, should these two messages NppExec's Console: \"Before saving file\" \"After saving file\". Very good far. Let's make our \"file_save\" script something more usefull. example, let's backup file if XML file. Our updated NppExec's script may look like following: // npp_console ? npp_console local - npe_console local m- -- npp_console local + echo Before saving file \"$(FULL_CURRENT_PATH)\" if \"$(EXT_PART)\" ~= \".xml\" then set local f ~ fileexists $(FULL_CURRENT_PATH) if $(f) != 0 then set local bakfile = $(FULL_CURRENT_PATH).bak cmd /C (if exist \"$(bakfile)\" del /F \"$(bakfile)\") & copy \"$(FULL_CURRENT_PATH)\" \"$(bakfile)\" endif endif // \".xml\" npp_save // saving file echo After saving file \"$(FULL_CURRENT_PATH)\" Now let's assume we run XmlLint against saved XML file results Notepad++. Also, let's comment unneeded messages: // npp_console ? npp_console local - npe_console local m- -- npp_console local + // echo Before saving file \"$(FULL_CURRENT_PATH)\" if \"$(EXT_PART)\" ~= \".xml\" then set local f ~ fileexists $(FULL_CURRENT_PATH) if $(f) != 0 then set local bakfile = $(FULL_CURRENT_PATH).bak cmd /C (if exist \"$(bakfile)\" del /F \"$(bakfile)\") & copy \"$(FULL_CURRENT_PATH)\" \"$(bakfile)\" endif endif // \".xml\" npp_save // saving file // echo After saving file \"$(FULL_CURRENT_PATH)\" if \"$(EXT_PART)\" ~= \".xml\" then \"xmllint.exe\" \"$(FULL_CURRENT_PATH)\" --output \"$(FULL_CURRENT_PATH)\" npp_sendmsg NPPM_RELOADFILE 0 \"$(FULL_CURRENT_PATH)\" endif This almost perfect. Each time we press Ctrl+S, backup copy previously saved XML file created, updated content saved file XmlLint run against saved file. may need specify full path \"xmllint.exe\" make work. , if interested XML, maybe doing something similar e.g. C++ using Artistic Style formatter - such case may need specify full path \"astyle.exe\". Let's actually example C++ files well. This requires additional modifications script: // npp_console ? npp_console local - npe_console local m- -- npp_console local + // echo Before saving file \"$(FULL_CURRENT_PATH)\" set local isXml = 0 set local isCpp = 0 if \"$(EXT_PART)\" ~= \".xml\" then set local isXml = 1 else if \"$(EXT_PART)\" ~= \".cpp\" then set local isCpp = 1 else if \"$(EXT_PART)\" ~= \".cxx\" then set local isCpp = 1 else if \"$(EXT_PART)\" ~= \".cc\" then set local isCpp = 1 else if \"$(EXT_PART)\" ~= \".c\" then set local isCpp = 1 else if \"$(EXT_PART)\" ~= \".hpp\" then set local isCpp = 1 else if \"$(EXT_PART)\" ~= \".hxx\" then set local isCpp = 1 else if \"$(EXT_PART)\" ~= \".hh\" then set local isCpp = 1 else if \"$(EXT_PART)\" ~= \".h\" then set local isCpp = 1 endif set local doBackup = 0 if \"$(isXml)\" == \"1\" then set local doBackup = 1 else if \"$(isCpp)\" == \"1\" then set local doBackup = 1 endif if \"$(doBackup)\" == \"1\" then set local f ~ fileexists $(FULL_CURRENT_PATH) if $(f) != 0 then set local bakfile = $(FULL_CURRENT_PATH).bak cmd /C (if exist \"$(bakfile)\" del /F \"$(bakfile)\") & copy \"$(FULL_CURRENT_PATH)\" \"$(bakfile)\" endif endif npp_save // saving file // echo After saving file \"$(FULL_CURRENT_PATH)\" if \"$(isXml)\" == \"1\" then \"xmllint.exe\" \"$(FULL_CURRENT_PATH)\" --output \"$(FULL_CURRENT_PATH)\" npp_sendmsg NPPM_RELOADFILE 0 \"$(FULL_CURRENT_PATH)\" else if \"$(isCpp)\" == \"1\" then \"astyle.exe\" \"$(FULL_CURRENT_PATH)\" npp_sendmsg NPPM_RELOADFILE 0 \"$(FULL_CURRENT_PATH)\" endif After doing , safely call yourself guru NppExec's scripting :-) started small draft now full-functional script that lot! only remaining thing message \"This file been modified by another program\" shown each time XML file modified by XmlLint (, case C++ file, each time modified by AStyle). deal with , we need modify one Notepad++'s option manually. Go Settings -> Preferences... -> MISC. -> File Status Auto-Detection. Check \"Update silently\" check-box. This will disable message \"This file been modified by another program\". (Ideally, would prefer programmatic disable enable this message, Notepad++ currently allow that. There internal message NPPM_INTERNAL_ENABLECHECKDOCOPT, though). Finally, after this NppExec's script debugged adjusted enough exactly , uncomment very first line \"// npp_console ?\". After that, NppExec's Console will automatically shown each time press Ctrl+S. Well done good luck!",
    "path": "./4.6.15.html"
  },
  "4.6.16. Open a file basing on the text selected in the editor": {
    "content": "4.6.16. Open file basing text selected editor wondering whether NppExec allows open file, say, \"C:\\Program Files (x86)\\Notepad++\\change.log\" when text \"Notepad++\\change.log\" selected editor. NppExec allow this! Here NppExec's script required this (please embedded comments clarifications): npp_console ? // process selected text... sci_sendmsg SCI_GETSELTEXT 0 @\"\" set local F = $(MSG_LPARAM) // selected text if \"$(F)\" != \"\" then // something selected // check current file name... set local n ~ strfind \"$(FILE_NAME)\" \"$(F)\" if $(n) == -1 then // current file name contain selected text // check already opened files... set local prev_fpath = $(FULL_CURRENT_PATH) npp_console local - npp_switch $(F) // try switch another file npp_console local + if \"$(FULL_CURRENT_PATH)\" == \"$(prev_fpath)\" then // did switch another file // check predefined directories... npe_console local v+ -- C:\\tools\\findfile.bat \"$(F)\" if \"$(OUTPUT1)\" != \"\" then // found predefined dir set local F = $(OUTPUT1) endif npp_open $(F) endif endif endif This NppExec's script uses external file \"C:\\tools\\findfile.bat\" which describes set predefined directories checked. Here possible content this \"findfile.bat\": @echo /D %%d ( \"C:\", \"C:\\Program Files\", \"C:\\Program Files (x86)\" ) ( if exist \"%%~d\\%~1\" ( call :EchoUnquotedString \"%%~d\\%~1\" ) ) goto End :EchoUnquotedString echo %~1 goto End :End predefined directories this example : \"C:\", C:\\Program Files\" \"C:\\Program Files (x86)\". define own set directories here. Here how works: NppExec's statement C:\\tools\\findfile.bat \"$(F)\" invokes external batch file, passing selected text argument ; inside \"C:\\tools\\findfile.bat\", when \"%%~d\\%~1\" exists, full path printed console output; then NppExec's statement if \"$(OUTPUT1)\" != \"\" checks whether output \"C:\\tools\\findfile.bat\" empty ; if empty, we take $(OUTPUT1) file name opened: set local F = $(OUTPUT1) ; finally, file opened by npp_open $(F) . Basing needs, batch file \"findfile.bat\" modified. example, use output git ls-files : @echo set WorkDir=C:\\Projects\\notepad-plus-plus cd /D \"%WorkDir%\" /F %%f ('git ls-files -- *%1*') ( call :EchoUnquotedString \"%WorkDir%\\%%~f\" ) goto End :EchoUnquotedString echo %~1 goto End :End",
    "path": "./4.6.16.html"
  },
  "4.6.17. Modify selected text and save to file": {
    "content": "4.6.17. Modify selected text save file Question: know that SEL_SAVETO will save selected text target file, how modify selected text such one blank line then save target file? Answer, option one: d say correct answer change order these operations: save selected text via SEL_SAVETO; modify saved file by external tool. example, sfk (Swiss File Knife) supports lot modify file, , moreover, supports commands chaining (.e. possible apply one modification, then apply another one result ), plus now support UTF-8 UCS-2 files. d recommend try use sfk additional file modifications. Here few examples how append/insert text lines by means sfk: append several lines similar cmd /c echo trailing line1>>myfile.txt cmd /c echo trailing line2>>myfile.txt use following: sfk echo -spat \"trailing line1\\ntrailing line2\" +append myfile.txt insert text before line 5: sfk filt -lnum myfile.txt +xed \"/[lstart]005 /005 text insert\\n[all]/\" +xed \"_[lstart]* __\" -tofile .txt insert after specific string (e.g. insert after line that contains string \"insert something after me\"): sfk xed myfile.txt \"/[lstart]*insert something after me*[eol]/[all] new text\\n/\" -tofile .txt Answer, option two: possible modify original text by means SCI_ commands, save modified text then undo changes. example, we append string following (this example works with entire document rather than with selected text): set local str ~ strfromhex 0D 00 0A 00 \" string\" // first 4 bytes \\r\\n set local str_len ~ strlensci $(str) sci_sendmsg SCI_APPENDTEXT $(str_len) \"$(str)\" // append string end document text_saveto $(SYS.TEMP)\\.txt // save output file sci_sendmsg SCI_UNDO // undo Here example that appends string existing selection, saves file then reverts text ( selection) previous state: // getting current selection sci_sendmsg SCI_GETCURRENTPOS set local pos = $(MSG_RESULT) sci_sendmsg SCI_GETANCHOR set local anchor = $(MSG_RESULT) if $(pos) < $(anchor) then set local pos1 = $(pos) set local pos2 = $(anchor) else set local pos1 = $(anchor) set local pos2 = $(pos) endif // appending string selection set local str ~ strfromhex 0D 00 0A 00 \" string\" // first 4 bytes \\r\\n set local str_len ~ strlensci $(str) sci_sendmsg SCI_INSERTTEXT $(pos2) \"$(str)\" // append string end selection set local pos2 ~ $(pos2) + $(str_len) sci_sendmsg SCI_SETSEL $(pos1) $(pos2) // update selection sel_saveto $(SYS.TEMP)\\.txt // save output file sci_sendmsg SCI_UNDO // undo // restoring original selection sci_sendmsg SCI_SETSEL $(anchor) $(pos) also: Applying external tool selected text ; Processing & replacing selection .",
    "path": "./4.6.17.html"
  },
  "4.6.2. Calculating": {
    "content": "4.6.2. Calculating course, use external tools calculations. All need select text which contains mathematical expression call NppExec's script which would allow calculate . example: set AWK_EXE = C:\\tools\\gawk\\gawk.exe \"$(AWK_EXE)\" \"BEGIN { print $(CURRENT_WORD) }\" This simple script allows calculate such expressions \"1 + sin(3)/4\" \"(2 + 0x10)*3\" . modify file \".awk\" previous example order calculate average value numbers given following table: 1. 552 2. 554 3. 549 4. 551 Here AWK script (.e. content \".awk\") which calculates average value numbers second column: BEGIN { Sum = 0 N = 0 } NF == 2 { Sum += $2 ++N } END { print \"avg = \" Sum/N \" (Sum = \" Sum \", N = \" N \")\" } Now, all have select given table ( above) Notepad++ execute NppExec's script \".awk selected text\". will following output NppExec's Console: avg = 551.5 (Sum = 2206, N = 4) course, use other external tools calculations selected expressions table data. output such external tools will shown NppExec's Console. Also redirect such output into text file then open that text file Notepad++ . NppExec ver. 0.4 introduces built- calculator abilities provided by Function Parser (fparser). example: // calculate math expression current line // usage: type math expression editor run this script NPP_CONSOLE ? // show Console if hidden SCI_SENDMSG SCI_GETCURLINE 100000 @\"\" // get current line set ~ $(MSG_LPARAM) // try calculate SCI_SENDMSG SCI_LINEEND // go end line SCI_SENDMSG SCI_REPLACESEL 0 \" = $()\" // result Type \"help set\" more details. also: Calculations, strlen .",
    "path": "./4.6.2.html"
  },
  "4.6.3. Processing & replacing the selection": {
    "content": "4.6.3. Processing & replacing selection There two ( forms) get text selected Notepad++: Using pre-defined variable $(CURRENT_WORD) which store limited number selected characters; Using pre-defined variable $(SELECTED_TEXT) which store number selected characters; Using SEL_SAVETO \"FilePathName\" save entire selected text into text file specified. Then selected text processed by external tool shown . There two ( forms) replace selected text with text : Using SEL_SETTEXT \"TextToReplaceWith\" which also use variable argument e.g. SEL_SETTEXT $(FILE_NAME); Using SEL_LOADFROM \"FilePathName\" load text text file specified. NppExec allows use both process selected text with external tool then replace text with tool's output. Several steps required: 1) Pass selected text external tool. selected text external tool's input: // input: command line, output: command line tool.exe <args> \"$(CURRENT_WORD)\"  // input: command line, output: file cmd /c tool.exe <args> \"$(CURRENT_WORD)\" >$(SYS.TEMP)\\.txt  // input: file, output: command line SEL_SAVETO $(SYS.TEMP)\\npp_sel.txt tool.exe <args> $(SYS.TEMP)\\npp_sel.txt  // input: file, output: file SEL_SAVETO $(SYS.TEMP)\\npp_sel.txt cmd /c tool.exe <args> C:\\npp_sel.txt >$(SYS.TEMP)\\.txt 2) Replace selected text with tool's output: // replace selected text with output file's content SEL_LOADFROM $(SYS.TEMP)\\.txt  // replace selected text with command line's output: SEL_SETTEXT $(OUTPUT) very last approach needs several additional steps. $(OUTPUT) variable stores entire external tool's output while NPE_CONSOLE V+ been set. Let's example such approach. Let's assume select word such \"copy\", \"dir\", \"cd\" . replace this word with description cmd's help. use $(CURRENT_WORD) variable pass selected word cmd.exe. Also replace selected word with cmd's output. use $(OUTPUT) variable . Here full NppExec's script which allows get desired result: // enable $(OUTPUT) variable within current NppExec's script NPE_CONSOLE local v+ // run cmd.exe with selected word parameter cmd.exe /c $(CURRENT_WORD) /? // (optional) replace selected text: previously selected word SEL_SETTEXT $(CURRENT_WORD) // (optional) replace selected text: new line SEL_SETTEXT+ \\n // replace selected text: cmd's output SEL_SETTEXT $(OUTPUT) That's all. Now try following: Create new file Notepad++ ( even save yet) Type, example, \"dir\" (without quotes) Select word \"dir\" (without quotes) Open NppExec's Execute window, select \"<temporary script>\" Copy script shown above Execute window's edit-box Press OK Enjoy result :-) $(OUTPUT) variable disabled by default minimize memory usage this variable stores entire external process'es output when enabled. clear this variable by assigning empty value : SET $(OUTPUT) = free memory allocated this variable, use following: UNSET $(OUTPUT) also: Applying external tool selected text ; Modify selected text save file .",
    "path": "./4.6.3.html"
  },
  "4.6.4. Running Python & wxPython": {
    "content": "4.6.4. Running Python & wxPython 1. Interactive Python inside NppExec Running \"python -?\" gives following help information, particular: - : inspect interactively after running script, (also PYTHONINSPECT=x) force prompts, even if stdin appear terminal -u : unbuffered binary stdout stderr (also PYTHONUNBUFFERED=x), man page details internal buffering relating '-u' text italic exactly refers stated NppExec's Manual, sections 1.3 3.1 by \"NppExec console emulator\". , by running \"python - -u\" NppExec's Console, get interactive Python inside Notepad++. Here advanced example NppExec's script used test Python's program interactively: npp_console local - // disable output Console npp_save // save current file ( .py file expected) cd \"$(CURRENT_DIRECTORY)\" // use current file's dir set local @exit_cmd_silent = exit() // allows exit Python automatically env_set local PATH = $(SYS.PATH);C:\\Python27 // using Python 2.7 npp_setfocus con // set focus Console npp_console local + // enable output Console python - -u \"$(FILE_NAME)\" // run Python's program interactively 2. Python UTF-8 If python's program contains non-ASCII characters, get following error Python: SyntaxError: Non-ASCII character able represent such non-ASCII characters correctly system, such source file should saved UTF-8 (either without BOM with BOM). Though error mentioned above still remains. avoid this error, acccording https://peps.python.org/pep-0263/ , just need specify # coding=utf-8  # -*- coding: utf-8 -*- beginning python's program. Another thing output something console UTF-8. this case, get something similar Python: UnicodeEncodeError: 'charmap' codec 't encode characters position 0-2: character maps <undefined> fix this last one, enough specify environment variable PYTHONIOENCODING by setting \"utf-8\". .e. // within NppExec env_set local PYTHONIOENCODING=utf-8 // UTF-8 output Python npe_console local -- o2 i2 // UTF-8 output/input NppExec's Console python my_program.py 3. Running Python scripts using wxPython [ text below been originally posted by cioma NppExec's forum] [ cioma: ] use NPP IDE Python. use NppExec run scripts directly NPP, highlight script syntax runtime errors (if ) link errors line code. time ago started using wxPython GUI library faced problems with running such scripts within NppExec. If run this ( NppExec prompt): python -t - -u \"$(FULL_CURRENT_PATH)\" ...then GUI part wxPython shown. guess reason that wxPython requires \"real\" console buffer NppExec doesn't provide that. If just run script over NPP \"Run\" dialog ( NppExec) then GUI shown if there errors there easily relate them line code NPP. found this solution work: 1. When creating wxPython application script make sure STDOUT redirected: app = App(redirect=False) 2. Run NppExec: cmd /C python -t - -u \"$(FULL_CURRENT_PATH)\" Voila! We have both wxPython GUI running STDOUT redirected NppExec. [ DV: ] Just one thing. more details regarding runtime errors parsing (keyword: Highlight filters), refer \"help con_filter\". 4. Running Pygame Code [ text below been originally posted by Ahmed . Notepad++'s forum] have NppExec set up with this script: npp_save cd $(CURRENT_DIRECTORY) python -u $(FILE_NAME) runs most python code perfectly fine, even tested example code that comes with python. Files using turtle module work perfectly with opening windows . However, when run code using Pygame module, everything works fine except that window opened . that code executing print statements game loop they show up console, that all. Eventually able get work. issue that NppExec somehow blocking window creation case Pygame. Using \"cmd /c python\" fixed issue with window: npp_save cd \"$(CURRENT_DIRECTORY)\" cmd /c python -u \"$(FILE_NAME)\" Here related comment superuser.com ( https://superuser.com/questions/381942/stop-nppexec--trapping-console-output-until-program-finishes ) where found solution this problem: prevent python script's own windows being suppressed ( sure exactly going here), run call Python argument cmd by preprending \"cmd /c\". example, m using cmd /c python -u \"$(FULL_CURRENT_PATH)\" my Cocos2D window shows up.",
    "path": "./4.6.4.html"
  },
  "4.6.5. Grab date & time to NppExec variable": {
    "content": "4.6.5. Grab date & time NppExec variable 1. grab current date NppExec variable, create following simple auxiliary script: NPE_CONSOLE local v+ cmd /c date /t set DATE = $(OUTPUTL) give name \"date\", example. Then use \"NPP_EXEC date\" just \"\\date\" call this script which sets internal environment variable $(DATE). same approach used time: just replace \"date /t\" with \"time /t\". 2. grab date time user-specified format, additional actions needed. First, go Notepad++'s folder (where notepad++.exe located) create file named \"date.bat\" with following content: @echo /f \"tokens=1-3 delims=/.- \" %% ('DATE /T') set CUR_DATE=%%c%%%% echo %CUR_DATE% Then create following NppExec's script which will use this bat-file: NPE_CONSOLE local v+ \"$(NPP_DIRECTORY)\\date.bat\" set DATE = $(OUTPUTL) // bat-file's output Now date format definitely determined by this line: /f \"tokens=1-3 delims=/.- \" %% ('DATE /T') set CUR_DATE=%%c%%%% change , e.g. /f \"tokens=1-3 delims=/.- \" %% ('DATE /T') set CUR_DATE=%%c-%%-%%  /f \"tokens=1-3 delims=/.- \" %% ('DATE /T') set CUR_DATE=%%c%%%% whatever . 3. Finally, use following bat-file which returns both date time one string: @echo /f \"tokens=1-3 delims=/.- \" %% ('DATE /T') set CUR_DATE=%%c%%%% /f \"tokens=1-2 delims=: \" %% ('TIME /T') set CUR_TIME=%%%% echo %CUR_DATE%_%CUR_TIME% 4. Here another version previous bat-file, now using cmd's environment variables %DATE% %TIME% which supports also milliseconds: @echo /f \"tokens=1-3 delims=/.- \" %% (\"%DATE%\") set CUR_DATE=%%c%%%% /f \"tokens=1-4 delims=:., \" %% (\"%TIME%\") set CUR_TIME=%%%%%%c%%d echo %CUR_DATE%_%CUR_TIME% also: Using cmd.exe .",
    "path": "./4.6.5.html"
  },
  "4.6.6. Grab Console output to new editor pane": {
    "content": "4.6.6. Grab Console output new editor pane open new editor pane, use \"NPP_SENDMSG WM_COMMAND IDM_FILE_NEW\". get Console output, notice usage \"NPE_CONSOLE v+\" \"SEL_SETTEXT $(OUTPUT)\" . sum up, following NppExec script should used: // enable $(OUTPUT) variable current NppExec's script NPE_CONSOLE local v+ // command here... example, let \"cmd /?\" cmd /? // open new editor pane NPP_SENDMSG WM_COMMAND IDM_FILE_NEW // set text new editor pane SEL_SETTEXT $(OUTPUT)",
    "path": "./4.6.6.html"
  },
  "4.6.7. Run and terminate PowerShell process": {
    "content": "4.6.7. Run terminate PowerShell process [Part 1: following text based nppexec/issues/23 by LorneCash] problem #1: If execute PowerShell's script NppExec's Console, PowerShell process ended when script finished. solution #1: Use \"cmd /c echo. | powershell\" instead \"powershell\" emulate sending Enter key PowerShell process. problem #2: PowerShell says: \"File ... loaded because running scripts disabled this system\". solution #2: Either use command-line option \"-ExecutionPolicy Unrestricted\" ( examples below) set PowerShell's global ExecutionPolicy ( second part this article). problem #3: If quoted file path passed second instance PowerShell, this second instance receives file path without quotes. solution #3: Use escaped quotes \\\" \\\" instead just \" \". Here example that illustrates this approach. Also demonstrates how PowerShell's ExecutionPolicy applied single script. assumed that .ps1 file currently opened Notepad++: cmd /c echo. | PowerShell -ExecutionPolicy Unrestricted start-process PowerShell -ArgumentList '-ExecutionPolicy Unrestricted -File \\\"$(FULL_CURRENT_PATH)\\\"' here example PowerShell's command executed NppExec's Console: cmd /c echo. | PowerShell -Command Write-Host 'Hello, World!' Now let's consider following scenario. When debugging PowerShell batch scripts usually run them lot with pauses them, end up with lot console windows that have closed manually. This automated by saving PID (process id) last running process then using this saved PID close that process gracefully. Here corresponding NppExec's script that runs PowerShell script file (.ps1) opened Notepad++: if \"$(PS_ID)\" != \"\" then // closing previous running process by id... cmd /C echo. | PowerShell -Command \"get-process -Id $(PS_ID) -ErrorAction SilentlyContinue | ForEach-Object {$null = $_.CloseMainWindow()};\" unset PS_ID endif // running new process saving id... npe_console local v+ -- cmd /C echo. | PowerShell -ExecutionPolicy Unrestricted -Command \"(start-process -PassThru PowerShell -ArgumentList '-File \"\"$(FULL_CURRENT_PATH)\"\"').Id\" set PS_ID = $(OUTPUT) case batch script file (.bat .cmd), NppExec's script will slightly different: if \"$(PS_ID)\" != \"\" then // closing previous running process by id... cmd /C echo. | PowerShell -Command \"get-process -Id $(PS_ID) -ErrorAction SilentlyContinue | ForEach-Object {$null = $_.CloseMainWindow()};\" unset PS_ID endif // running new process saving id... npe_console local v+ -- cmd /C echo. | PowerShell -Command \"(start-process -PassThru cmd -ArgumentList '/c \"\"$(FULL_CURRENT_PATH)\"\"').Id\" set PS_ID = $(OUTPUT) Finally, we merge these two NppExec's scripts into new NppExec's script that will take both PowerShell batch script files: npp_console ? // show Console if hidden npp_save // save current file if \"$(PS_ID)\" != \"\" then // closing previous running process by id... cmd /C echo. | PowerShell -Command \"get-process -Id $(PS_ID) -ErrorAction SilentlyContinue | ForEach-Object {$null = $_.CloseMainWindow()};\" unset PS_ID endif // batch file?.. set local IS_BATCH_FILE = false if \"$(EXT_PART)\" ~= \".bat\" then set local IS_BATCH_FILE = true else if \"$(EXT_PART)\" ~= \".cmd\" then set local IS_BATCH_FILE = true endif // running new process saving id... npe_console local v+ -- if \"$(IS_BATCH_FILE)\" == \"true\" then cmd /C echo. | PowerShell -Command \"(start-process -PassThru cmd -ArgumentList '/c \"\"$(FULL_CURRENT_PATH)\"\"').Id\" set PS_ID = $(OUTPUT) else if \"$(EXT_PART)\" ~= \".ps1\" then cmd /C echo. | PowerShell -ExecutionPolicy Unrestricted -Command \"(start-process -PassThru PowerShell -ArgumentList '-File \"\"$(FULL_CURRENT_PATH)\"\"').Id\" set PS_ID = $(OUTPUT) else messagebox \"File type been configured NppExec's 'Run' script\" : \"NppExec: Run - Unknown File Type\" : warn endif [Part 2: text below originally posted NppExec's forum] problem: if execute PowerShell's script NppExec's Console, PowerShell process ended when script finished. solution: use \"cmd /c echo. | powershell\" instead \"powershell\" emulate sending Enter key PowerShell process. Here example full NppExec's script that uses currently selected text PowerShell's program: // path PowerShell.exe set local PS_EXE = C:\\WINDOWS\\system32\\windowspowershell\\v1.0\\powershell.exe // temporary file set local TEMP_FILE = $(SYS.TEMP)\\ps_sel.ps1 // save selected text current file temporary ANSI file SEL_SAVETO $(TEMP_FILE) : // execute temporary file PowerShell exit cmd /c echo. | \"$(PS_EXE)\" -nologo \"$(TEMP_FILE)\" Note: If PowerShell unexpectedly says something like File \"test.ps1\" loaded because running scripts disabled this system could related fact that there 32-bit 64-bit instances 64-bit systems, they have different settings. According https://stackoverflow.com/questions/4037939/powershell-says-execution--scripts--disabled--this-system , following should help: x86 (32 bit) Open \"C:\\Windows\\SysWOW64\\cmd.exe\" Run command: \"powershell Set-ExecutionPolicy RemoteSigned\" x64 (64 bit) Open \"C:\\Windows\\system32\\cmd.exe\" Run command: \"powershell Set-ExecutionPolicy RemoteSigned\" check bitness using - CMD: echo %PROCESSOR_ARCHITECTURE% - Powershell: [Environment]::Is64BitProcess also: Using cmd.exe .",
    "path": "./4.6.7.html"
  },
  "4.6.8. Clipboard, keystrokes and much more": {
    "content": "4.6.8. Clipboard, keystrokes much more always extend NppExec's functionality by using different external tools. example: NirCmd ( https://www.nirsoft.net/ ) allows work with clipboard, send keystrokes system, modify Registry ini-files - much more; Swiss File Knife ( https://sourceforge.net/projects/swissfileknife/ ) allows various operations text binary files; wget ( https://eternallybored.org/misc/wget/ ) allows download network; winapiexec ( https://ramensoftware.com/winapiexec ) allows run WinAPI functions through command line parameters; gawk ( Windows: https://sourceforge.net/projects/ezwinports/ ) allows write special-purpose programs (scripts) simple data-reformatting jobs. list such useful programs go - main idea here ability \"communication\" between these programs NppExec. use different tools with different parameters then retrieve process produced output, there theoretically limit achieve by this approach. This reminds us section : \", generally speaking, NppExec tool\" - this tool depends how use . use wisely :) also: Working with Notepad++ 'Replace' dialog ; Notepad++ Clipboard Monitor .",
    "path": "./4.6.8.html"
  },
  "4.6.9. Send several commands to external tool": {
    "content": "4.6.9. Send several commands external tool piping technique used send several commands external tool. Let's take standard \"cmd\" example. Let's assume have text file with list commands cmd execute. Let's name this file \"c.txt\" have following lines : ECHO Let's execute DIR command... DIR ECHO Done! ECHO Now let's help CD command... CD /? ECHO Done! Note: forget press Enter have end--line (CR/LF) after very last line! far understand, last command (\"ECHO Done!\" our case) may incorrectly understood if there's new line after . Now execute following NppExec's Console: cmd /C type c.txt | cmd believe same technique should work with external tool well - e.g.: cmd /C type c.txt | external_tool unless external tool itself accept piping. generally this approach should work. also: Using cmd.exe .",
    "path": "./4.6.9.html"
  },
  "4.7. Compiling": {
    "content": "4.7. Compiling",
    "path": "./4.7.html"
  },
  "4.7.1. Compiling simple C and Pas-programs": {
    "content": "4.7.1. Compiling simple C Pas-programs 1. edit, compile & run simple C-programs directly Notepad++. All need following: 1) download tcc (Tiny C Compiler freeware C-compiler, 1 MB archive) 2) unpack tcc \"C:\\tools\\tcc\" create \"tcc\" subfolder Notepad++ folder ( example, \"C:\\Program Files\\Notepad++\\tcc\") unpack tcc there 3) run Notepad++ call \"Execute NppExec Script...\" dialog (Plugins -> NppExec -> Execute NppExec Script... - just press F6). 4) type these commands \"Execute NppExec Script...\" dialog: 4.1) if tcc placed C:\\tools\\tcc // save current file NPP_SAVE // enable built- error highlight filter locally NPE_CONSOLE local -- x+ // compile & run with tcc C:\\tools\\tcc\\tcc.exe -run \"$(FULL_CURRENT_PATH)\" 4.2) if tcc placed $(NPP_DIRECTORY)\\tcc // save current file NPP_SAVE // enable built- error highlight filter locally NPE_CONSOLE local -- x+ // compile & run with tcc \"$(NPP_DIRECTORY)\\tcc\\tcc.exe\" -run \"$(FULL_CURRENT_PATH)\" 5) save these commands: press Save... button, type \"tcc-run\" (this name script) press Save. Now, when have C source file opened Notepad++, call \"Execute NppExec Script...\" dialog, select \"tcc-run\" press OK compile & run this C-file. this case tcc works interpreter C source file ( option \"-run\" : use \"tcc -?\" learn more). If need produce output .exe file, just remove \"-run\" option. 2. By similar technique, compile Pascal files using Free Pascal (FPC): NPP_SAVE // save current file set local PathToFpcExe = C:\\FPC\\2.6.0\\bin\\i386-win32 // path fpc.exe env_set local PATH = $(SYS.PATH);$(PathToFpcExe) // path fpc.exe %PATH% cd $(CURRENT_DIRECTORY) // go directory current file NPE_CONSOLE local -- x+ // enable built- error highlight filter locally fpc \"$(FILE_NAME)\" // use fpc.exe compile",
    "path": "./4.7.1.html"
  },
  "4.7.2. Compiling Java": {
    "content": "4.7.2. Compiling Java [This article uses text originally posted by Sam (sammi101082) Notepad++'es Help forum.] [ Sam: ] compile Java file, all have following: Navigate Plugins -> NppExec -> Execute. (Default Shortcut key F6) new popup window, type this NPE_CONSOLE local -- x+ // enable built- error highlight filter locally cmd /c cd \"$(CURRENT_DIRECTORY)\" && \"%JAVA_HOME%\\bin\\javac\" \"$(FULL_CURRENT_PATH)\" Click \"Save\" give name say \"Java Compile\". Bingo. there. Now Java file editing Notepad++ compiled by pressing F6 choosing this script \"Java Compile\". will compile Java class . This irrespective which directory . NppExec plugin used execute executable would command prompt. running compiled Java class, script : NPE_CONSOLE local -- x+ // enable built- error highlight filter locally cmd /k cd \"$(CURRENT_DIRECTORY)\" && \"%JAVA_HOME%\\bin\\java\" \"$(NAME_PART)\" && exit P.S. Remember set JAVA_HOME environment variable. check if set, open command prompt type java. [ DV: ] Actually, same thing done without explicit usage 'cmd.exe'. use several commands (one command per line) NppExec's script, these commands will executed one by one. example: NPE_CONSOLE local -- x+ // enable built- error highlight filter locally cd \"$(CURRENT_DIRECTORY)\" \"$(SYS.JAVA_HOME)\\bin\\javac\" \"$(FULL_CURRENT_PATH)\" Also use ENV_SET set environment variables such PATH JAVA_HOME process (program) start Notepad++ .",
    "path": "./4.7.2.html"
  },
  "4.7.3. Using Visual Studio's compiler (cl.exe)": {
    "content": "4.7.3. Using Visual Studio's compiler (cl.exe) If run 'cl.exe' NppExec, requires additional environment. Such environment set using batch file using NppExec's command ENV_SET . 1. Using batch file (simple) use simple batch file, create file 'cl.cmd' with similar text: REM cl.cmd REM Visual Studio 2017 Community Edition @echo call \"%ProgramFiles(x86)%\\Microsoft Visual Studio\\2017\\Community\\VC\\Auxiliary\\Build\\vcvarsall.bat\" x86 cl.exe %* Now, use NppExec's script similar NPE_CONSOLE local -- x+ // enable built- error highlight filter locally cl.cmd \"$(FULL_CURRENT_PATH)\" compile source file(s). 2. Using batch file (advanced) use advanced batch file, create file 'cl.cmd' with similar text: REM cl.cmd REM Visual Studio 8.0 (2005) Express @echo Set VCDIR=C:\\Program Files\\Microsoft Visual Studio 8\\VC Set VSCOMMON=C:\\Program Files\\Microsoft Visual Studio 8\\Common7\\IDE Set MSSDK=C:\\Program Files\\Microsoft Platform SDK Windows Server 2003 Set PATH=%VCDIR%\\bin;%MSSDK%\\bin;%VSCOMMON%;%PATH% Set INCLUDE=%MSSDK%\\include;%VCDIR%\\include;%INCLUDE% Set LIB=%MSSDK%\\lib;%VCDIR%\\lib;%LIB% cl.exe %* Now, use NppExec's script similar NPE_CONSOLE local -- x+ // enable built- error highlight filter locally cl.cmd \"$(FULL_CURRENT_PATH)\" compile source file(s). , VC's environment handled inside 'cl.cmd' this case. .e. handled by system (well, by cmd.exe) by NppExec. 3. Using running (interactive) VS Developer Command Prompt following NppExec's script used run Developer Command Prompt VS 2022 NppExec's Console: set local @exit_cmd = exit // sends \"exit\" when NppExec's Console closed cmd /K \"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Auxiliary\\Build\\vcvarsall.bat\" x86 Now, while VS Developer Command Prompt running NppExec's Console, possible e.g. compile current file via following command NppExec's Console: cd /D \"$(CURRENT_DIRECTORY)\" && cl \"$(FILE_NAME)\" 4. Using ENV_SET initialization environment variables VC will look similar following: // setting NppExec's internal (user) variables SET local VCDIR = C:\\Program Files\\Microsoft Visual Studio 8\\VC SET local VSCOMMON = C:\\Program Files\\Microsoft Visual Studio 8\\Common7\\IDE SET local MSSDK = C:\\Program Files\\Microsoft Platform SDK Windows Server 2003 R2 // setting NppExec's child process'es environment variables // (due \"local\", previous values environment // variables will restored when this script ends) ENV_SET local PATH = $(VCDIR)\\bin;$(MSSDK)\\bin;$(VSCOMMON);$(SYS.PATH) ENV_SET local INCLUDE = $(MSSDK)\\include;$(VCDIR)\\include;$(SYS.INCLUDE) ENV_SET local LIB = $(MSSDK)\\lib;$(VCDIR)\\lib;$(SYS.LIB) // enabling built- error highlight filter locally NPE_CONSOLE local -- x+ // executing child process with specified environment variables rc /r /\"$(CURRENT_DIRECTORY)\\Resources.res\" \"$(CURRENT_DIRECTORY)\\Resources.rc\" cl.exe \"$(FULL_CURRENT_PATH)\" forget that ENV_SET understand such form existing environment variables \"%PATH%\" because NppExec accept such declaration. \"$(SYS.PATH)\" should used instead \"%PATH%\". general, good idea set then restore environment every time needed by tool. Instead, set all required environment NppExec's start-up script . Such approach would allow use tools without further specifying full paths additional environment variables. 5. Using ENV_SET, VS 10 + clang [ text below originally posted by Suman Kar NppExec's forum.] have spent good couple hours getting this work. Finally, able coax NppExec, clang Visual Studio work together let me compile my C snippets. following script (along with \"compile_or_run\" described documentation ) worked me: // run@.cpp.txt // setting NppExec's internal (user) variables SET local VCBASE=C:\\Program Files\\Microsoft Visual Studio 10.0 SET local VCDIR = $(VCBASE)\\VC SET local VSCOMMON = $(VCBASE)\\Common7\\IDE SET local MSSDK = C:\\Program Files\\Microsoft SDKs\\Windows\\v7.0A // setting NppExec's child process'es environment variables // (due \"local\", previous values environment // variables will restored when this script ends) ENV_SET local PATH = $(VCDIR)\\bin;$(MSSDK)\\bin;$(VSCOMMON);$(SYS.PATH) ENV_SET local INCLUDE = $(MSSDK)\\include;$(VCDIR)\\include;$(SYS.INCLUDE) ENV_SET local LIB = $(MSSDK)\\lib;$(VCDIR)\\lib;$(SYS.LIB) // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ///! NOTE: change following folder where clang binary resides SET local clangc = D:\\llvm_workspace\\llvm\\build\\bin\\Debug\\clang.exe // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ SET local obj = $(CURRENT_DIRECTORY)\\$(NAME_PART) // enabling built- error highlight filter locally NPE_CONSOLE local -- x+ // run clang \"$(clangc)\" \"$(FULL_CURRENT_PATH)\" - \"$(obj).exe\" cmd /c \"$(obj).exe\" Things note: am using Visual Studio 2010 (installed C:\\Program Files\\) 32-bit Windows 7 box with NppExec 0.4.2.1 my clang 3.0 binaries reside D:\\llvm_workspace\\llvm\\build\\bin\\Debug\\ (built with Visual Studio 2010). will need change appropriate paths script course depending installation.",
    "path": "./4.7.3.html"
  },
  "4.7.4. Compiling ANY source file": {
    "content": "4.7.4. Compiling source file Compiling source file using NppExec assumes following: - usage external compilers/interpreters compile ( run) source file(s); - creating specific NppExec's scripts compiling ( running) specific source files; - creating general NppExec's script which would allow use different compilers/interpreters different source files; - usage NppExec's Highlight filters parse compiler's/interpreter's output (warnings, errors ). find all this information inside \" \". Please refer . (, before proceed, sure understand section .)",
    "path": "./4.7.4.html"
  },
  "4.8. Advanced details": {
    "content": "4.8. Advanced details",
    "path": "./4.8.html"
  },
  "4.8.1. Logging": {
    "content": "4.8.1. Logging According \"doc\\NppExec\\NppExec_TechInfo.txt\", NppExec's logging enabled by specifying 'LogsDir' parameter under [Options] section \"NppExec.ini\". full path \"NppExec.ini\" configuration file obtained via echo $(PLUGINS_CONFIG_DIR) even npp_open $(PLUGINS_CONFIG_DIR)\\NppExec.ini enable logging, just something similar LogsDir=\"NppExecLogs\" under [Options] section \"NppExec.ini\". Once done, restart Notepad++ go folder \"%TEMP%\\NppExecLogs\". will contain subfolder \"NppExec\" subfolder with current date under . ll find NppExec's log files there. Here typical beginning NppExec's log file: 22:00:17.618 7388 Log start >> 22:00:17.618 7388 ; CNppExec::ReadOptions - start 22:00:17.619 7388 ; CNppExec::ReadOptions - end 22:00:17.619 7388 ; CNppExecCommandExecutor - started 22:00:17.699 7388 ; NPPN_READY - start first column time format hours:minutes:seconds.milliseconds. second column thread identifier (NppExec uses different threads perform different activities, such processing GUI commands, running collateral scripts, ). Here typical ending NppExec's log file: 22:01:26.454 7388 ; NPPN_SHUTDOWN - end 22:01:26.465 7388 ; CNppExecCommandExecutor: waiting ExecuteThreadDoneEvent... 22:01:26.465 7388 ; CNppExecCommandExecutor - stopped 22:01:26.467 7388 Log exit. absence \"Log exit.\" end NppExec's log file (assuming Notepad++ exited) would mean that either NppExec itself Notepad++ whole hung crashed. Such crash hang could caused by other Notepad++'s plugin , more rare cases, by NppExec Notepad++ itself. If NppExec's fault, last line log file least shows last successful activity before hang crash. Note: NppExec's logger internally calls fflush() after each logged line. may look excessive, case hang crash helps ensure that log file contain everything that could have been logged. would definitely help with investigation. general, NppExec's logging great help when something goes wrong go expected. That why there special command NPE_DEBUGLOG that enables NppExec's \"logging\" directly into NppExec's Console window. This command create output log file (unless 'LogsDir' parameter specified \"NppExec.ini\") - instead prints detailed information each NppExec's command activity NppExec's Console. This information quite similar ( would ) written NppExec's log file, though NppExec's log file usually contains little bit more information. enable this \"debug logging\", use npe_debuglog just npe_debug 1 this mode, NppExec also shows additional information when NppExec's hot-key pressed also when line NppExec's Console double-clicked. latter allows \"debug\" Console Highlight Filters - shows matched filter (if ) double-clicked line. Example: Plugins -> NppExec -> Console Output Filters, specify e.g. \"*error* : %FILE%\" one HighLight masks, check enable , press OK; type \"echo error : file name\" NppExec's Console press Enter; type \"npe_debug 1\" NppExec's Console press Enter; double-click previously printed line \" error : file name\". result, Notepad++ says that file \" file name\" exist proposes create . Obviously need create this file just test :) here NppExec's Console shows: ; Console's line double-clicked ; WarningAnalyzer info ; { ; Input line: \" error : file name\" ; Match result: true ; Active filter: \"*error* : %FILE%\" ; * Parsed File Name: \" file name\" ; * Parsed Line Number: <none> ; * Parsed Char Position: <none> ; }",
    "path": "./4.8.1.html"
  },
  "4.8.2. Collateral scripts": {
    "content": "4.8.2. Collateral scripts think, subject collateral scripts NppExec (introduced NppExec v0.6) deserves separate article. let's . We'll start with simple examples, explain their background then proceed technical details how implemented NppExec. Let's start something easy. Type following NppExec's Console: cmd press Enter. cmd.exe now running NppExec's Console. If now type \"cmd\" once again, ll have first cmd.exe executing second cmd.exe. let's try something different. Now, with cmd.exe running, type following NppExec's Console: nppexec:cmd \"nppexec:\" prefix instructs NppExec pass this command running process ( cmd.exe our case), execute NppExec's own command instead. Thus \"nppexec:cmd\" (executed within already running cmd.exe) differs just \"cmd\" following : just \"cmd\" executed by means running process (.e. by cmd.exe our example); \"nppexec:cmd\" executed by NppExec itself; just \"cmd\" makes running instance cmd.exe start new instance cmd.exe wait until this second instance finished; \"nppexec:cmd\" runs _parallel_ instance cmd.exe, while previous instance cmd.exe still active background. This called \"collateral\" NppExec. Let's look another, more advanced, example. Consider following Python program: import time def run(): xrange(5): time.sleep(3) print run() This program basically cycle where integers 0 4 printed with interval 3 seconds. Here equivalent program C: #include <stdio.h> #include <windows.h> void run() { ; ( = 0; < 5; ++) { Sleep(3000); printf(\"%d\\n\", ); fflush(stdout); // important! otherwise output may buffered inside pipe } } main() { run(); return 0; } comment possible buffering inside pipe relates NppExec - because NppExec uses pipes redirect console process'es output input. stated before, am still stating now, this \"feature\" buffering pipes something infused by incorrectly handled by NppExec - core \"feature\" pipes they were implemented by Microsoft. This known years - still been fixed. use fflush() whenever program expected run without real console window (e.g. when run NppExec). Surely need either Python C compiler installed machine proceed. just create similar program using other language prefer. case Python, please sure that path python.exe been added PATH environment variable. case C, please ensure path C compiler (such Tiny C Compiler GCC) been added PATH environment variable. If sure how deal with PATH environment variable, please search internet this ensure understand prior further reading this article. Here few links related %PATH%, just case: https://en.wikipedia.org/wiki/PATH_(variable) https://ss64.com/nt/path.html Also, sure check \"Follow $(CURRENT_DIRECTORY)\" NppExec: select \"Plugins\" Notepad++'s main menu, then \"NppExec\", then check \"Follow $(CURRENT_DIRECTORY)\". Now, case Python, type: nppexec:python -u \"$(FILE_NAME)\" NppExec's Console run Python program mentioned above. ( assume Python program been saved into file, e.g. \"test.py\", this file currently opened Notepad++.) case Tiny C Compiler, type: nppexec:tcc -run \"$(FILE_NAME)\" case GCC, type: nppexec:cmd /c gcc \"$(FILE_NAME)\" - \"$(NAME_PART).exe\" && \"$(NAME_PART).exe\" again, assumed C program been saved into file, e.g. \"test.c\", this file currently opened Notepad++. \"nppexec:\" prefix here have special meaning while nothing currently running NppExec's Console. we'll need this prefix little bit later. moment, though, just imagine this prefix present - just type actually. Once type one previously mentioned commands ( other command applicable another programming language using) press Enter NppExec's Console, here expected output: 0 1 2 3 4 ================ READY ================ Now, let's think following. There interval 3 seconds between each output - if run another NppExec's command during that time? This where NppExec's collateral scripts come . Remember initial command with \"nppexec:\" prefix? Now here meaning : when there already running process NppExec, NppExec execute NppExec's command _while working with this running process_, \"nppexec:\" prefix tells NppExec pass (give) this command NppExec itself rather than running process. this command will executed same time running process executing, collateral command. Let's practice. Follow these steps: Copy command clipboard (e.g. 'nppexec:python -u \"$(FILE_NAME)\"' command case Python); Paste this command NppExec's Console (via Ctrl+V) press Enter; Wait until \"0\" \"1\" have been printed; Now paste same command again (via Ctrl+V) press Enter. interval between output integers 3 seconds, need hurry with these last Ctrl+V Enter. Basically, this reason why mentioned \"nppexec:\" prefix before: able copy command clipboard advance, then just paste clipboard. expected output will similar ( case Python): nppexec:python -u \"$(FILE_NAME)\" python -u \"test.py\" Process started (PID=1620) >>> 0 1 nppexec:python -u \"$(FILE_NAME)\" python -u \"test.py\" Process started (PID=1776) >>> 0 1 2 3 4 <<< Process finished (PID=1776). (Exit code 0) 2 3 4 <<< Process finished (PID=1620). (Exit code 0) ================ READY ================ This output with \" internal messages\" unchecked - such more clear where each process'es output . We notice following things here: first process'es output available NppExec's Console while second (collateral) process running. Once second process finished, rest first process'es output printed. This call \"postponed output\" - output process that running background. run many embedded collateral commands (with \"nppexec:\" prefix) need. terms example above, just press Ctrl+V Enter while second process running, then press Ctrl+V Enter while third process running, . NppExec limitation this. NppExec's built- help provides other examples with \"nppexec:\" prefix. Type one following NppExec's Console: help npe_queue help proc_signal help @exit_cmd Now here interesting hint. case two running processes ( last example with Python above), clear that once second process printed \"2\", first process background already printed \"4\" finished. if call \"Execute NppExec Script...\" (F6 by default) now, NppExec allows that even though second process still running NppExec's Console! because only first process \"regular\" command terms NppExec, whereas second process \"collateral\". after \"regular\" process finished, \"Execute NppExec Script...\" becomes available, disregarding running \"collateral\" process. (Though, may changed future :)) now let's discuss how possible how collateral commands implemented NppExec. NppExec v0.6, core NppExec CommandExecutor ( CNppExecCommandExecutor class). CommandExecutor responsible execution CommandExecutor's Command (sounds logical, isn't ? ;)). terms CommandExecutor, Command anything that initiated UI (user interface) NppExec's Plugin Interface. example, attempt run command NppExec's Console CommandExecutor's Command; attempt run \"Execute NppExec Script...\" (F6 by default) also CommandExecutor's Command; attempt close NppExec's Console exit Notepad++ also CommandExecutor's Command. m writing \"Command\" capital letter confuse with command that entered NppExec's Console part NppExec's script (by this \"command\" small letter mean anything like \"cmd\", \"help\", \"npp_console \" ). CommandExecutor's Command two methods: Execute() Expire(). method Expire() called when Command started during ChildScript_SyncTimeout_ms time interval ( 200 ms by default, refer \"NppExec_TechInfo.txt\"). This happen when another script command already running NppExec's Console. method Expire() invokes method CanStartScriptOrCommand() that checks whether running process (if ) exited. If possible, method Execute() will called. Otherwise Command marked \"expired\" will executed. Here how NppExec's log file looks like case regular (non-collateral) command: ; @Input Command: cmd ; RunScriptCommand - create (instance = 0x320CBA8 @ 20:21:20.588) ; RunScriptCommand - executing (instance = 0x320CBA8 @ 20:21:20.588) ; CScriptEngine - create (instance = 0x32589B8 @ 20:21:20.589) ; CScriptEngine::Run - start (instance = 0x32589B8 @ 20:21:20.589) Let's explain this. RunScriptCommand CommandExecutor's Command responsible running (executing) anything ( command) NppExec's Console. This RunScriptCommand creates CScriptEngine instance delegates actual execution command . because NppExec operates with NppExec's scripts, even single command NppExec's script (that consists this single command). Another source NppExec's scripts \"Execute NppExec Script...\" (F6 by default) that leads following NppExec's log file: ; Hot-key: executing function [0], \"Execute NppExec Script...\" ; ExecDlgCommand - create (instance = 0xA53D50 @ 20:27:45.520) ; ExecDlgCommand - executing (instance = 0xA53D50 @ 20:27:45.520) GetCmdType() { ... } ; CScriptEngine - create (instance = 0xA59AC0 @ 20:27:51.815) ; CScriptEngine::Run - start (instance = 0xA59AC0 @ 20:27:51.815) this case we have ExecDlgCommand responsible \"Execute NppExec Script...\" dialog. Also we have several extra lines related \"GetCmdType()\" that pre-processes NppExec's script obtained \"Execute\" dialog. anyway, we have Command instance CScriptEngine instance. CScriptEngine responsible actual execution given NppExec's script (remember, NppExec's script contain either several commands single command). , CScriptEngine recognizes command itself (via getCmdType method), preprocesses command arguments (via modifyCommandLine method) invokes one specific methods finally execute command known type. , let's repeat: case regular (non-collateral) Command, corresponding Command instance created first ( initiate execution something), then CScriptEngine instance created execute NppExec's script. Surely, we have CScriptEngine instance case CloseConsoleCommand NppExitCommand since these Commands associated with NppExec's script executed, let's concentrate Commands that . By , we already mentioned NppExec's log files here, let's say how get them. Please refer \"NppExec_TechInfo.txt\" details. Now, returning our Commands NppExec's scripts, let's how NppExec's log file looks like case collateral (non-regular) command: ; @Child Process'es Input: nppexec:cmd CheckCmdAliases() { ... } ; Executing collateral script... ; CScriptEngine - create (instance = 0xA59AC0 @ 20:50:10.710) ; CScriptEngine::Run - start (instance = 0xA59AC0 @ 20:50:10.710) Did notice that? Only instance CScriptEngine created, without Command! because collateral commands scripts wait previous command/script finished - they executed parallel. allow this, CommandExecutor's method ExecuteCollateralScript() following: creates CScriptEngine instance ( execute NppExec's script); executes this CScriptEngine instance separate thread. Thus, more collateral scripts, more separate threads running NppExec, with own instance CScriptEngine each thread. Talking threads, they created NppExec demand. If script/command executed NppExec yet, thread created. Once Command needs executed, thread CNppExecCommandExecutor::BackgroundExecuteThreadFunc created. Once Command expire, thread CNppExecCommandExecutor::BackgroundExpiredThreadFunc created. Once NppExec's script needs send notification via NppExec's Plugin Interface, thread BackgroundSendMsgThreadFunc created. Once NPEM_EXECUTE_COLLATERAL NPEM_EXECUTE_QUEUED received through NppExec's Plugin Interface, thread BackgroundExecAsyncCmdThreadFunc created. Too many threads, might say. Probably, last 3 spend most their time WaitForMultipleObjects(2, waitEvents, FALSE, INFINITE) - .e. sleeping. BackgroundExecuteThreadFunc most active one, place where Command->Execute() called. Consequently, this where CScriptEngine instance running regular NppExec's scripts. , mentioned before, collateral NppExec's scripts running their own, separate, threads. think that's basically all collateral regular scripts NppExec. Part 2. prefixes \"nppexec:\" \"nppexec::\". Now let's compare prefixes \"nppexec:\" \"nppexec::\" highlight differences between them. prefix \"nppexec:\" executes NppExec's scripts either normally (when nothing currently running by NppExec) parallel (creating new thread, when e.g. child process currently running by NppExec); shares local variables with parent NppExec's script. Thus, possible e.g. nppexec:set local x = 10 within running instance cmd.exe ( NppExec's Console), then nppexec:set local x prints \"local $(X) = 10\". such local variable actually local parent NppExec's script, collateral one. these main 2 differences between collateral scripts created via \"nppexec:\" prefix via NPEM_EXECUTE_COLLATERAL message ( NppExec's plugin interface): NPEM_EXECUTE_COLLATERAL always executes NppExec's scripts parallel (creating new thread); NPEM_EXECUTE_COLLATERAL never shares local variables. this exact description \"nppexec::\" prefix (with double \"::\") . \"nppexec::\" prefix always executes NppExec's scripts parallel (creating new thread); never shares local variables. other words, \"nppexec::\" prefix mirrors behavior NPEM_EXECUTE_COLLATERAL message. Thus, typing nppexec::set local x = 10 then nppexec::set local x prints \" user-defined local variables\", set local x prints \" such user's local variable: $(X)\".",
    "path": "./4.8.2.html"
  },
  "4.8.3. Console child process workflow": {
    "content": "4.8.3. Console child process workflow Well, let's follow all steps child console process'es execution. (1) beginning, there NppExec's script. script's commands (which will executed) located inside `g_nppExec.m_ScriptCmdList` - bidirectional list strings. Each string separate command. (2) CmdList (list commands) passed CNppExecCommandExecutor: ... CNppExecCommandExecutor::ScriptableCommand * pCommand = new CNppExecCommandExecutor::DoRunScriptCommand(tstr(), CmdList, nRunFlags); GetCommandExecutor().ExecuteCommand(pCommand); ... method ExecuteCommand() simply given Command queue: m_ExecuteQueue.push_back( std::shared_ptr<Command>(cmd) ); ... m_ExecuteCmdEvent.Set(); (3) thread BackgroundExecuteThreadFunc monitors m_ExecuteQueue executes given command this thread (thus, main thread): ... auto& ExecuteQueue = pCommandExecutor->m_ExecuteQueue; isExecuteQueueEmpty = ExecuteQueue.empty(); if ( !isExecuteQueueEmpty ) pCommand = ExecuteQueue.front(); ... if ( !isExecuteQueueEmpty ) { if ( pCommand ) { if ( !pCommand->IsExpired() ) pCommand->Execute(); // pCommand contains CmdList } ... } (4) pCommand->Execute() eventually calls CScriptEngine::Run() where all commands CmdList finally executed. ensure by looking brief code this method: ... CListItemT<tstr>* p = m_CmdList.GetFirst(); // first list item while ( p && ContinueExecution() ) { ... S = p->GetItem(); // extract string if (S.length() > 0) { ... nCmdType = ModifyCommandLine(this, S, ifState); ... } p = (m_execState.pScriptLineNext == INVALID_TSTR_LIST_ITEM) ? p->GetNext() : m_execState.pScriptLineNext; // next list item } ... following line: nCmdType = ModifyCommandLine(this, S, ifState); returns identifier internal command such NPP_EXEC, NPP_RUN . Also, expands (substitutes corresponding values) variables such $(FILE_NAME), $(NPP_DIRECTORY) . here how command `S` executed: m_nCmdType = nCmdType; ... m_sCmdParams = S; EXECFUNC pCmdExecFunc = m_CommandRegistry.GetCmdExecFunc(m_nCmdType); nCmdResult = pCmdExecFunc(this, S); (5) When `nCmdType` 0 (.e. CMDTYPE_UNKNOWN), means following: current string contain internal NppExec's command, interpreted external command - .e. path executable file. Let's look corresponding method which pCmdExecFunc points this case: CScriptEngine::eCmdResult CScriptEngine::(const tstr& params) { ... std::shared_ptr<CChildProcess> proc(new CChildProcess(this)); ... proc->Create(m_pNppExec->GetConsole().GetDialogWnd(), params.c_str()) ... } , calls method CChildProcess::Create, where `params` parameter passed value `S` mentioned above. , let's refer CChildProcess::Create. (6) first intelligible thing inside CChildProcess::Create creation input/output pipes (m_hStd Input/Output Read/Write Pipe). These pipes \"information channels\" between NppExec plugin child process which will created soon. forget pipes - we'll return them later. second intelligible thing actually creation child process. Here corresponding code: // initialize STARTUPINFO struct ZeroMemory(&si, sizeof(STARTUPINFO)); si.cb = sizeof(STARTUPINFO); si.dwFlags = STARTF_USESHOWWINDOW | STARTF_USESTDHANDLES; si.wShowWindow = SW_HIDE; si.hStdInput = m_hStdInReadPipe; // pipe user's input (stdin) si.hStdOutput = m_hStdOutWritePipe; // pipe process'es stdout si.hStdError = m_hStdOutWritePipe; // pipe process'es stderr ... tstr sCmdLine = cszCommandLine; ... if ( ::CreateProcess(NULL, sCmdLine.c_str(), ...) ) { ... } second parameter CChildProcess::Create (this parameter corresponds `params` `S` mentioned above) passed system's function CreateProcess. This parameter path executable which will run child process plugin. (7) Now child process created. Let's assume console process. remember, whole CScriptEngine::Run() method running another thread, this child process created handled that thread also. NppExec Console serves child console process'es output input while this process running. .e. when type string ConsoleDlg's RichEdit control press Enter, this string will passed child process. find corresponding code inside \"ConsoleDlg::OnNotify\" function inside \"DlgConsole.cpp\". Search \"GetCommandExecutor().ExecuteChildProcessCommand\". let's return capturing child process'es output. (8) This code capturing: CStrT<char> bufLine; // buffer child process'es output bool bPrevLineEmpty = false; bool bDoOutputNext = true; nPrevState = 0; DWORD dwRead = 0; ... { dwRead = readPipesAndOutput(bufLine, bPrevLineEmpty, nPrevState, false, bDoOutputNext); ... } while ( (isConsoleProcessRunning = (::WaitForSingleObject(m_ProcessInfo.hProcess, dwCycleTimeOut) == WAIT_TIMEOUT)) && m_pScriptEngine->ContinueExecution() && !isBreaking() ); // NOTE: time- inside WaitForSingleObject() prevents 100% CPU usage! if ( m_pScriptEngine->ContinueExecution() && (!isBreaking()) && !m_pScriptEngine->GetTriedExitCmd() ) { // maybe child process exited all data read readPipesAndOutput(bufLine, bPrevLineEmpty, nPrevState, true, bDoOutputNext); } We try read data console process (by means pipes) while process finished while plugin's ConsoleDlg visible. \"readPipesAndOutput\" method actually all work capturing child console process'es output showing this output ConsoleDlg. (9) whole \"readPipesAndOutput\" method drive crazy ( wrote this method by parts ;-)) , brief, very simple: ... { Sleep(10); // prevents 100% CPU usage while reading! dwBytesRead = 0; if ( !::PeekNamedPipe(m_hStdOutReadPipe, NULL, 0, NULL, &dwBytesRead, NULL) ) { dwBytesRead = 0; } ... if ( (dwBytesRead > 0) || bOutputAll ) { // data Pipe bOutputAll==true bool bContainsData = (dwBytesRead > 0) ? true : false; // without bContainsData==true ReadFile operation will never return if ( bContainsData ) ::ZeroMemory(Buf, CONSOLEPIPE_BUFSIZE); dwBytesRead = 0; if ( (bContainsData && ::ReadFile(m_hStdOutReadPipe, Buf, (CONSOLEPIPE_BUFSIZE-1)*sizeof(char), &dwBytesRead, NULL) && (dwBytesRead > 0)) || bOutputAll ) { // data been read Pipe bOutputAll==true ... } } } while ( (dwBytesRead > 0) && m_pScriptEngine->ContinueExecution() && !isBreaking() ); , first we verify if there something pipe: ::PeekNamedPipe(..., &dwBytesRead, ...) ... bool bContainsData = (dwBytesRead > 0) ? true : false; then we read data: ReadFile(...) here problem. Sometimes PeekNamedPipe returns FALSE returns dwBytesRead == 0 though data must output pipe already. July 2023, this issue with PeekNamedPipe still relevant. PeekNamedPipe still sometimes returns FALSE returns dwBytesRead == 0 when data already been written by console child process output - thus this data expected present output pipe. , PeekNamedPipe returns FALSE dwBytesRead == 0. if we call ReadFile that point, just return until pipe internally \"decides\" give data away. This relevant Windows 2000, XP, Vista, 7, 8, 8.1, 10 11. Microsoft even introduced -called PseudoConsole Windows 10, still fixed this buggy implementation PeekNamedPipe. This only reason why sometimes output NppExec's Console while output expected. data inside pipe's internal buffer there get there. Sad true.",
    "path": "./4.8.3.html"
  },
  "5. Other": {
    "content": "5. Other",
    "path": "./5.html"
  },
  "About": {
    "content": " user manual NppExec written by DV. Initially converted CHM format by Greg Webb. Version history: 1.0 - April 2009 1.1 - January 2010 (sections 4.6.3 4.6.4 added) 1.2 - April 2010 (sections 3.7, 4.1 4.6.2 updated) 1.3 - July 2010 (4.5, 4.6.2 4.6.3 updated; 4.6.5 4.6.6 added) 1.4 - November 2011 (3.1, 3.4, 4.6.1 4.7.4 updated; 3.8.4, 4.0 4.6.7 added) 1.5 - May 2012 (3.1 4.7.3 updated) 1.6 - April 2013 (3.8.4 updated; 4.6.8 added) 1.7 - January 2014 (2.1, 2.3, 3.1, 3.8.2, 4.6.1, 4.6.4, 4.7.1, 4.7.3, '' 'NppExec_Guide' updated) 1.8 - November 2014 (corrections 3.7, 3.8.1, 4.2, 4.7.1) 1.9 - February 2015 (3.4 updated; 4.6.9 added) 2.0 - September 2015 (uses \"style.css\" now) 2.1 - May 2018 (various sections slightly updated) 2.2 - June 2018 (3.3, 4.4, 4.6.7 slightly updated; 4.6.10, 4.8.1 4.8.2 added) 2.3 - April 2019 (clickable links, various sections slightly updated) 2.4 - September 2020 (several \" also\" references added; 1.1, 2.3, 2.5, 4.6.7 4.7.3 updated) 2.5 - July 2021 (reflecting latest changes; 'NppExec_Guide' updated; 3.8.5, 4.6.11 4.6.12 added) 2.6 - February 2022 ('NppExec_Guide.txt' converted HTML updated; 3.4, 4.2, 4.6.8, 4.7.1, 4.7.2, 4.7.3 updated) 2.7 - April 2022 (1.2 3.5 updated) 2.8 - June 2022 (4.6.13 added; 4.6.8 updated; `META NAME=\"Generator\"` removed) 2.9 - June 2023 (3.8.5 updated; `!DOCTYPE` nodes added, `lang` attribute added `HTML` nodes) 3.0 - August 2023 (4.6.14, 4.6.15 4.8.3 added; 4.6.3, 4.6.4, 4.7.1 NppExec_Guide updated) 3.1 - September 2023 (2.4, 3.7, 3.8.4, 4.1, 4.6.4 4.7.3 updated; 4.6.16 4.6.17 added)",
    "path": "./About.html"
  },
  "Acknowledgment": {
    "content": "Acknowledgments This CHM file been created with HTML Help Workshop. Thanks Greg Webb converting original text (ver.1.0) Keynote CHM. Thanks NppExec's users who inspired parts this Manual. Thanks Joseph Samuel rdipardo bringing Manual online: https://d0vgan.github.io/nppexec/",
    "path": "./Acknowledgment.html"
  },
  "Guide: Using NppExec to compile sources with associated compilers": {
    "content": "Guide: Using NppExec compile sources with associated compilers Notepad++ user, did ever think ability compile source file with associated compiler single action? may use NppExec plugin perform certain actions files, automatization? if .c files compiled with tcc, .cpp files compiled with g++ .awk files interpretted with gawk automatically, without explicit call required compiler interpreter? possible? Yes, NppExec Let's begin with several theoretical questions. first, how NppExec understand which compiler/interpreter required by current source file? NppExec compiler, have information file know with . Moreover, Notepad++ itself such IDE Visual Studio Dev-C++, include compiler also know with source file. , only compile source file with required compiler tell Notepad++ ( tell NppExec our case) This solution which may use already - explicit usage certain compiler/interpreter with certain source file. example, may compile run .c source file with tcc (Tiny C Compiler). simple NppExec's script created this purpose: \"C:\\tools\\tcc\\tcc.exe\" -run \"$(FULL_CURRENT_PATH)\" full path \"C:\\tools\\tcc\\tcc.exe\" specifies path required compiler; Notepad++'es environment variable \"$(FULL_CURRENT_PATH)\" specifies full path name current source file; \"-run\" tcc's command line means \"run compiled source\". full path given quotes, because, general, contain spaces. Now, we talking NppExec's script. This assumes script been created saved with name which identified that script. If sure NppExec's script creation & saving, let me guide . create & save NppExec's script, following: 1) Open \"Execute NppExec Script...\" window: press hotkey (F6) select (main menu) Plugins -> NppExec -> Execute NppExec Script... 2) Type text script \"Execute NppExec Script...\" window. example: \"C:\\tools\\tcc\\tcc.exe\" -run \"$(FULL_CURRENT_PATH)\" 3) Save this new script: press \"Save...\" button, type script name ( example, type \"run@.c\") press Save. Now compile & run single .c file opened Notepad++. , press F6 (default hotkey \"Execute NppExec Script...\" window), select \"run@.c\" combo-box press OK. press Ctrl+F6 (by default) execute same script again without showing \"Execute NppExec Script...\" window. , currently have call \"run@.c\" script explicitly order compile & run .c source file. Thus, compile & run another source file (.cpp, .asm, .php, .lua, ...) also have call corresponding script explicitly. [ last sentence assumes have created separate scripts every language use (.cpp, .asm, .php, .lua, ...)]. However, we call required script explicitly. We NppExec call \"run@.c\" script .c file call different script required different (.cpp, .asm, .php, .lua, ...) file automatically. , question: how we ? first part answer source file's extension. There such environment varible $(EXT_PART) which contains extension current file opened Notepad++. second part answer NppExec's internal command NPP_EXEC. probably know already, this command expects existing script name script file name first argument. purpose this command execute specified NppExec's script. Thus, if use NPP_EXEC command, first argument ( script executed) depends current file's extension, call different scripts different file types one starting script! Let's examine more detail. We create general NppExec's script which would allow us call different scripts different source files depending their extension. other words, we use NPP_EXEC command call required script, script name depends current file's extension. name script above, \"run@.c\", consists two parts: prefix \"run@\" extension \".c\". file's extension got Notepad++, we write general form this script's name: \"run@$(EXT_PART)\". hard understand that this script's name transforms \"run@.cpp\" .cpp source file, \"run@.lua\" .lua source file . , let's create our general compile--run script which will called each time compile run // save current file NPP_SAVE // construct script name called SET Compiler = run@$(EXT_PART) // enable built- error highlight filter locally NPE_CONSOLE local -- x+ // call script NPP_EXEC \"$(Compiler)\" Save this script \"compile_or_run\". Now this only starting script which will allow compile run However, forget that this script requires existing scripts every source file compile. Thus, \"run@.cpp\" must exist compile .cpp file, \"run@.php\" must exist compile .php file . several examples such scripts below: // run@.c \"C:\\tools\\tcc\\tcc.exe\" -run \"$(FULL_CURRENT_PATH)\" // run@.cpp SET local g++ = C:\\Dev-Cpp\\bin\\g++.exe SET local obj = $(CURRENT_DIRECTORY)\\$(NAME_PART) \"$(g++)\" -c \"$(FULL_CURRENT_PATH)\" - \"$(obj).\" \"$(g++)\" \"$(obj).\" - \"$(obj).exe\" NPP_RUN \"$(obj).exe\" // run@.awk \"C:\\tools\\gawk\\gawk.exe\" -f \"$(FULL_CURRENT_PATH)\" All these scripts will started automatically \"compile_or_run\" script .c, .cpp .awk files. create more \"run@...\" scripts support source file extension use. Now, let's return our \"compile_or_run\" script. uses NPP_EXEC command which supports script file name first argument. mean? means execute NppExec's script file. , current implementation \"compile_or_run\" script requires lot additional \"run@...\" scripts exist together with other scripts which may call explicitly. same time, call \"run@...\" scripts explicitly. , \"run@...\" scripts may undesired NppExec's script combo-box ( \"Execute NppExec Script...\" window). Thus, may modify \"compile_or_run\" script order call script files instead internal scripts. example: // compile_or_run NPP_SAVE SET Compiler = C:\\tools\\NppExec Scripts\\run@$(EXT_PART).txt NPE_CONSOLE local -- x+ NPP_EXEC \"$(Compiler)\" Now need create directory \"C:\\tools\\NppExec Scripts\" which will contain following files: \"run@.c.txt\", \"run@.cpp.txt\", \"run@.awk.txt\" . text these files will exactly same scripts \"run@.c\", \"run@.cpp\" \"run@.awk\" above. E.g. file \"C:\\tools\\NppExec Scripts\\run@.awk.txt\" must contain \"C:\\tools\\gawk\\gawk.exe\" -f \"$(FULL_CURRENT_PATH)\" other file extensions (.c, .cpp, ...). Similarly, path NppExec Scripts relative Notepad++. example: // compile_or_run NPP_SAVE SET Compiler = $(NPP_DIRECTORY)\\NppExec Scripts\\run@$(EXT_PART).txt NPE_CONSOLE local -- x+ NPP_EXEC \"$(Compiler)\"  // compile_or_run NPP_SAVE SET Compiler = $(PLUGINS_CONFIG_DIR)\\NppExec Scripts\\run@$(EXT_PART).txt NPE_CONSOLE local -- x+ NPP_EXEC \"$(Compiler)\" Such approach allows use external text files NppExec Scripts, while they always available since they reside Notepad++'s folder. read more information NPP_EXEC command, open NppExec's Console Notepad++, type: help npp_exec press Enter. read more information NPE_CONSOLE command, type: help npe_console press Enter. get general NppExec's help information, type just help press Enter. may have noticed, that script \"compile_or_run\" uses non-local variable $(Compiler), such : SET Compiler = run@$(EXT_PART) Though, general, recommended use local variable, e.g. SET local Compiler = run@$(EXT_PART) Local variables, unlike non-local ones, automatically deleted end script where they were created. ( have use UNSET command local variables end script.) , why variable $(Compiler) local one? Consider situation when \"run@...\" script expected . such case, probably examine this script correct , right? here when existing variable $(Compiler) becomes useful! this variable holds name ( path ) just executed \"run@...\" script, easy exact \"run@...\" script needs examined. Just type one following NppExec's Console: // show \"run@...\" script's name: echo $(Compiler) // open \"run@...\" script physical file: NPP_OPEN $(Compiler) Starting NppExec v0.6 alpha 1, IF...ELSE IF...ELSE...ENDIF sequences supported NppExec's scripts ( \"help if\"). means we create single NppExec's script that will deal with all file types we . example: // setting internal messages , error highlight filter NPE_CONSOLE local m- x+ -- // saving current file NPP_SAVE // file extension lower case set local ext ~ strlower $(EXT_PART) // compiling/running... if $(ext) == .c \"C:\\tools\\tcc\\tcc.exe\" -run \"$(FULL_CURRENT_PATH)\" else if $(ext) == .cpp env_set local PATH = $(path);C:\\mingw32\\bin; set local obj = $(CURRENT_DIRECTORY)\\$(NAME_PART) cmd /C del \"$(obj).\" 2>nul & del \"$(obj).exe\" 2>nul echo Compiling... \"g++\" -c \"$(FULL_CURRENT_PATH)\" if $(EXITCODE) == 0 \"g++\" \"$(obj).\" - \"$(obj).exe\" echo Running... NPP_RUN cmd /C if exist \"$(obj).exe\" \"$(obj).exe\" && echo. && pause endif else if $(ext) == .awk \"C:\\tools\\gawk\\gawk.exe\" -f \"$(FULL_CURRENT_PATH)\" else messagebox \"Unknown file type!\" endif Such single script includes everything one place. one , nice have everything one place. other , will create issues with maintenance performance future. Maintenance. time goes by, more more file types (languages) will added this single script. script will grow - will harder harder find exact things within script. Moreover, if different parts script will share common functionality (, least, common variables) ll decide make changes common functionality point, will most likely lead unexpected effects different places. ( example, may change affect only certain languages, fact will affect more them). , bigger script will become, more accurate ll need with each single change within script. Performance. bigger script will become, more time NppExec will need process entire script. good thing : NppExec's engine internally fast enough handle very big scripts without noticeable delay. bad thing : NppExec's user interface ( NppExec Console) very slow when there lot messages printed. Here good news: easy reduce number messages printed NppExec's Console - thus enhance overall performance. presense \" NPE_CONSOLE local m- \" beginning script already reduces number messages NppExec prints Console. Going further, explicitly specify when disable enable NppExec's output, thus having complete manual control when NppExec prints something Console when . Just notice that ll need update each IF-ELSE block achieve that: // disabling output NppExec's Console NPP_CONSOLE local - // setting internal messages , error highlight filter NPE_CONSOLE local m- x+ -- // saving current file NPP_SAVE // file extension lower case set local ext ~ strlower $(EXT_PART) // compiling/running... if $(ext) == .c NPP_CONSOLE local + // enabling output NppExec's Console \"C:\\tools\\tcc\\tcc.exe\" -run \"$(FULL_CURRENT_PATH)\" else if $(ext) == .cpp env_set local PATH = $(path);C:\\mingw32\\bin; set local obj = $(CURRENT_DIRECTORY)\\$(NAME_PART) cmd /C del \"$(obj).\" 2>nul & del \"$(obj).exe\" 2>nul NPP_CONSOLE local + // enabling output NppExec's Console echo Compiling... \"g++\" -c \"$(FULL_CURRENT_PATH)\" if $(EXITCODE) == 0 \"g++\" \"$(obj).\" - \"$(obj).exe\" echo Running... NPP_RUN cmd /C if exist \"$(obj).exe\" \"$(obj).exe\" && echo. && pause endif else if $(ext) == .awk NPP_CONSOLE local + // enabling output NppExec's Console \"C:\\tools\\gawk\\gawk.exe\" -f \"$(FULL_CURRENT_PATH)\" else NPP_CONSOLE local + // enabling output NppExec's Console messagebox \"Unknown file type!\" endif One more thing regarding NppExec usage. Compiler/interpreter's output shown NppExec's Console parsed by NppExec. means that different error/warning messages shown using different colours, jump corresponding line source file by double-clicking such warning error message NppExec's Console. enable such parsing, must tell NppExec form these error/warning messages have (.e. specify message mask). configure (main menu) Plugins -> NppExec -> Console Output Filters... -> HighLight. That window contains example parsing (highlighting) masks GCC: Example 1: %ABSFILE%:%LINE%: warning:* => detects warning lines gcc Example 2: %ABSFILE%:%LINE%: error:* => detects error lines gcc .e. enable detection (parsing) GCC errors NppExec, must specify mask compiler's error line (\"%ABSFILE%:%LINE%: error:*\") , optionally, specify Red, Green Blue components line highlighted , also optionally, this line shown using Italic, Bold / Underlined font typeface. , course, corresponding check-box must checked enable this parsing mask. example, if GCC's errors Bold lines with Red colour GCC's warnings Italic lines with Blue colour, will look similar following: [v] [%ABSFILE%:%LINE%: error:* ] 0x80 0x00 0x00 [ ] [v] [ ] [v] [%ABSFILE%:%LINE%: warning:* ] 0x00 0x00 0x80 [v] [ ] [ ] find more notes hints by typing help con_filter Well, seems time finish guide. hope this guide usefull , because otherwise waste time both us: reader () writer (me). Anyway, thank time interest! If like this guide, hope will inspire find own usefull application NppExec's functions, maybe share with us.",
    "path": "./NppExec_Guide.html"
  },
  "NppExec Manual": {
    "content": "NppExec Manual",
    "path": "./NppExec%20Manual.html"
  },
  "Questions/suggestions?": {
    "content": "Questions/suggestions? Did find answer question? try following: Read this manual once again ;) Visit https://sourceforge.net/projects/npp-plugins/ search NppExec's forum answer ask question there. Visit https://github.com/d0vgan/nppexec/issues/ search closed open issues. Have suggestion? Visit NppExec's forum let me know.",
    "path": "./Questions_suggestions.html"
  },
  "Title Page": {
    "content": "NppExec User Guide by Vitaliy Dovgan Notepad++ Plugin that Allows Run Commands Programs Directly Editor User Guide Version 3.1 September 2023",
    "path": "./0.%20Title%20Page.html"
  }
}